<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-04-25T01:07:05.352Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[我作为新经理所犯的一些错误]]></title>
        <id>https://www.benkuhn.net/newmgr/</id>
        <link href="https://www.benkuhn.net/newmgr/"/>
        <updated>2023-04-25T00:56:17.319Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.benkuhn.net/newmgr/">Some mistakes I made as a new manager</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了作者成为管理者的经历，以及他在这个过程中犯下的错误和解决策略。作者指出，作为一名管理者，最初的困难之一是难以确定自己的工作是否有用。他提供了三种应对策略：与上级领导沟通，寻求反馈，多元化生活体验。此外，作者还分享了其他的经验教训，如管理的重要性、任务相关成熟度、拖延维护、直接询问等。最后，作者总结了成为新管理者的困难所在，并鼓励读者不要害怕犯错，因为这是成长的必经之路。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 装饰器：完整指南]]></title>
        <id>https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/</id>
        <link href="https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/"/>
        <updated>2023-04-25T00:45:02.471Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/">TypeScript Decorators: A complete guide</a></p><p><strong>概要：</strong></p><p>本文介绍了 TypeScript 的装饰器，装饰器本质上是函数，可以用于给类、方法、属性等应用可重用的行为。不同类型的装饰器包括类装饰器、方法装饰器、属性装饰器、访问器装饰器和参数装饰器。装饰器可以用于实现各种功能，如前 / 后钩子、监视属性更改和方法调用、转换参数、自动序列化和反序列化、依赖注入等。使用装饰器的优点包括跨越关注点、依赖注入、验证和代码组织。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - partykit/partykit：有了朋友，一切都更好。]]></title>
        <id>https://github.com/partykit/partykit</id>
        <link href="https://github.com/partykit/partykit"/>
        <updated>2023-04-25T00:43:43.337Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/partykit/partykit">GitHub - partykit/partykit: Everything's better with friends.</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 partykit 的软件开发工具包，可以用于构建实时协作应用程序。用户可以将其与现有的 Web 应用程序一起使用，也可以从头开始构建新的应用程序。该工具包提供了简单易用的服务器和客户端代码，使用户能够轻松地添加实时协作功能，如协同编辑器、多人游戏等。此外，文章还介绍了 y-partykit 和 party.io 两个相关的库，可以帮助用户更方便地构建协作应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新的断点侧边栏如何帮助您更快地进行调试 - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/en/blog/breakpoint-ux-redesign/</id>
        <link href="https://developer.chrome.com/en/blog/breakpoint-ux-redesign/"/>
        <updated>2023-04-25T00:23:16.053Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/en/blog/breakpoint-ux-redesign/">How the new Breakpoints sidebar helps you debug faster - Chrome Developers</a></p><p><strong>概要：</strong></p><p>Google Chrome 最新版本的调试工具已经更新了断点侧边栏的设计。这个更新旨在提高断点调试的效率，通过提供更好的断点概览、更直观易用的用户工作流程和更可见的断点特性来实现。更新后的断点侧边栏集中于使现有功能更加直观易用，而非添加新功能。更新后的功能包括：暂停异常以调查代码错误、管理断点（展开相关断点组、折叠其他组、单击跳转到代码位置、删除或启用 / 禁用断点）以及使用条件断点和日志点等不太常用的断点特性。如果您有进一步的建议或反馈，请通过 crbug.com 提交。同时，建议使用 Chrome Canary、Dev 或 Beta 版本作为默认开发浏览器，以获得最新的 DevTools 功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[“const” 欺骗]]></title>
        <id>https://www.joshwcomeau.com/javascript/the-const-deception/</id>
        <link href="https://www.joshwcomeau.com/javascript/the-const-deception/"/>
        <updated>2023-04-25T00:12:35.864Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshwcomeau.com/javascript/the-const-deception/">The “const” Deception</a></p><p><strong>概要：</strong></p><p>本文介绍了 JavaScript 中的 const 关键字，它用于声明常量。虽然 const 声明的对象是不可重新赋值的，但我们仍然可以修改该对象的属性或元素。文章讲解了变量名作为标签、重新分配标签和修改数据等概念，并介绍了原始数据类型的特点。最后，作者推荐了一些深入学习 JavaScript 的资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年，Rust 能否击败 JavaScript？]]></title>
        <id>https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023</id>
        <link href="https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023"/>
        <updated>2023-04-24T08:43:58.611Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023">Can Rust Beat JavaScript in 2023?</a></p><p><strong>概要：</strong></p><p>本文介绍了 Rust 作为 Web 开发语言的优势。尽管在过去，一些人认为使用 Rust 前端开发（通过 WASM）比 JavaScript 慢或者不够成熟，但是现在已经不再是问题。实际测试表明，Rust WASM 框架如 Leptos 和 Dioxus 在性能上超越了大多数 JavaScript 框架，同时 Rust 也有着出色的后端性能，在 TechEmpower 的排名中占据了五个前十名的位置。此外，Rust 还具有良好的开发体验和错误处理机制，并且拥有完善的生态系统来支持数据库、Redis、Stripe 支付等服务。最后，文章介绍了 Shuttle 作为部署 Rust 应用的工具。总之，Rust 是一个非常值得使用的 Web 开发语言，可以提供更好的性能、更低的内存占用和更好的服务稳定性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[职业建议：辞职时提前通知很重要]]></title>
        <id>https://davidlaprade.github.io/give-a-lot-of-notice</id>
        <link href="https://davidlaprade.github.io/give-a-lot-of-notice"/>
        <updated>2023-04-24T01:03:24.977Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://davidlaprade.github.io/give-a-lot-of-notice">Career Advice No One Gave Me: Give a Lot of Notice When You Quit</a></p><p><strong>概要：</strong></p><p>在辞职时，通常给予两周的提前通知是黄金标准。但是，给予更长时间的通知实际上有很多好处。这些好处包括：只做自己最喜欢的工作部分、消除所有工作压力、获得相同的薪水、延长福利期限、休假时间没有使用、股票归属权增加、获得奖金、留下积极的印象、受到感谢和赞赏等。如果你是一名能干的软件工程师，并且在公司中地位良好，那么给予超过两周的通知通常对所有人都是有利的。此外，给予更长时间的通知还可以使公司更顺利地进行转型，减少风险等。

为什么公司会同意这样做呢？通常情况下，需要签署延长通知期的人是工程师的经理，可能还包括人力资源部门。但是，如果你的</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[是时候学习 oklch 颜色了。]]></title>
        <id>https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/</id>
        <link href="https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/"/>
        <updated>2023-04-24T01:01:10.314Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/">It's time to learn oklch color</a></p><p><strong>概要：</strong></p><p>本文介绍了最新的 CSS 颜色标记法，包括 hwb ()、lab ()、lch ()、oklab ()、oklch () 和 color ()。文章推荐学习 oklch () 标记法，因为它基于人眼感知而不是技术限制，可以定义任何颜色，并且支持更广泛的色域。此外，文章还提到了使用 oklch () 时需要注意的一些问题，如 chroma 值的范围和 hue 值的变化等。最后，文章推荐了一个在线颜色选择器 oklch.com，方便调试和转换其他颜色格式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[批判性思维是软件工程师最重要的技能吗？]]></title>
        <id>https://blog.pragmaticengineer.com/critical-thinking/</id>
        <link href="https://blog.pragmaticengineer.com/critical-thinking/"/>
        <updated>2023-04-24T01:00:31.080Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.pragmaticengineer.com/critical-thinking/">Is Critical Thinking the Most Important Skill for Software Engineers?</a></p><p><strong>概要：</strong></p><p>这篇文章谈到了两个现象：技术术语的使用和 “思想领袖” 在社交媒体上的崛起，以及这些现象对批判性思维的影响。作者认为，过度使用技术术语可能掩盖了人们对某一概念的真正理解，而 “思想领袖” 的观点也不应该被轻易地接受，需要进行深入的研究和验证。作者建议人们提高批判性思维能力，包括理解技术术语、验证信息、问 “为什么” 和 “如何”，并避免跟风。最后，作者强调批判性思维将在未来变得越来越重要，因为随着人工智能工具的普及，我们需要更多的人来质疑和思考。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么你应该在社区大学教书]]></title>
        <id>https://timozander.de/blog/why-you-should-teach/</id>
        <link href="https://timozander.de/blog/why-you-should-teach/"/>
        <updated>2023-04-24T00:36:52.865Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://timozander.de/blog/why-you-should-teach/">Why you should teach at a Community College</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了作者作为软件开发者教授 IT 课程的经历，并总结了教学对于软件开发者的好处。首先，教学可以帮助开发者更好地了解普通用户的需求和使用习惯，从而改善软件的用户体验；其次，教学可以提高开发者的语言表达能力，让他们更好地将复杂概念简单易懂地传达给学生；最后，教学本身也是一种学习，通过教学可以不断提升自己的技能和知识水平。作者建议开发者在编写指导文档时要详细、清晰地说明每一个步骤，同时要注意避免使用过多的技术术语和缩略语。此外，作者还鼓励有志于成为教师的人士加入到 STEM 教育中来，为缓解教师短缺问题做出贡献。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么在 React 中你不需要信号（Signals）]]></title>
        <id>https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/</id>
        <link href="https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/"/>
        <updated>2023-04-24T00:36:07.525Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/">Why You Don't Need Signals in React</a></p><p><strong>概要：</strong></p><p>本文介绍了信号在 React 中的两个方面：反应式原语和绕过 diffing。反应式是 React 的一个关键特性，可以通过 useState 创建反应式原语来定义状态，并触发重新渲染。为了简化全局状态的定义和使用，第三方库 Jotai 可以很有用。Jotai 提供了 atoms 来定义全局状态，这些 atoms 可以表示状态的定义，也可以定义依赖于其他 atoms 的派生状态。与 useState 不同，useAtom 不是局部状态，可以在另一个组件中使用来共享 atom 状态。另一个重要的特性是绕过 diffing。React 通过比较 UI 的先前和当前表示来更新 DOM，以确定已更改的内容并仅更新 DOM 的那些部分，从而实现更好的性能和响应性。然而，绕过 diffing 可能会导致 UI 不一致，并使应用程序更难理解。因此，在决定绕过 diffing 之前，需要全面评估性能收益并权衡潜在风险。总之，Jotai 提供了一种更简单</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[说不要 "闪烁" 的 UI：使用 useLayoutEffect，绘画和浏览器故事]]></title>
        <id>https://www.developerway.com/posts/no-more-flickering-ui</id>
        <link href="https://www.developerway.com/posts/no-more-flickering-ui"/>
        <updated>2023-04-24T00:34:43.692Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/no-more-flickering-ui">Say no to "flickering" UI: useLayoutEffect, painting and browsers story</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中如何根据 DOM 测量更改元素的基础知识。文章首先通过一个响应式导航组件的例子，讲解了如何使用 useEffect 来计算容器大小和每个元素的尺寸，并且根据这些信息来调整元素的数量。然而，这种方法会导致初始渲染时出现闪烁问题。为了解决这个问题，文章介绍了 useLayoutEffect 的用法，并解释了浏览器渲染、绘制和事件循环等相关概念。最后，文章还讨论了在 Next.js 等服务器端渲染框架中使用 useLayoutEffect 的问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🔥 掌握 ReactJS 优化 - ITNEXT]]></title>
        <id>https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f</id>
        <link href="https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f"/>
        <updated>2023-04-24T00:19:26.031Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f">🔥 Mastering ReactJS optimization - ITNEXT</a></p><p><strong>概要：</strong></p><p>本文介绍了一些优化 React 应用程序的关键技术。首先，文章列举了常见的性能瓶颈，如大型包大小、慢渲染和网络请求不优化等。接着，文章介绍了一些优化策略，包括代码分割、懒加载、记忆化、分析器和服务器端渲染。通过掌握这些技术，可以创建快速响应、用户体验良好的 React 应用程序。其中，代码分割是将代码拆分成小块，在需要时按需加载，从而减少初始加载时间的强有力的优化技术；懒加载则是仅在需要时加载模块，而不是预加载所有内容，同样可以提高应用程序的性能。此外，文章还介绍了记忆化、分析器和服务器端渲染等其他优化技术。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们如何让 Vite 4.3 更快]]></title>
        <id>https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html</id>
        <link href="https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html"/>
        <updated>2023-04-22T02:32:50.851Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html">How we made Vite 4.3 faaaaster</a></p><p><strong>概要：</strong></p><p>Vite 4.3 是一个快速的 JavaScript 构建工具，它在性能方面进行了改进。这篇文章介绍了 Vite 4.3 是如何通过优化解析策略、使用异步函数、并行处理和 JavaScript 优化等方式来提高性能的。此外，该文章还介绍了一些与 Vite 4.3 相关的基准测试生态系统和插件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 v5.80.0・webpack/webpack]]></title>
        <id>https://github.com/webpack/webpack/releases/tag/v5.80.0</id>
        <link href="https://github.com/webpack/webpack/releases/tag/v5.80.0"/>
        <updated>2023-04-21T02:20:51.852Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/webpack/webpack/releases/tag/v5.80.0">Release v5.80.0 · webpack/webpack</a></p><p><strong>概要：</strong></p><p>本文介绍了 Webpack v5.80.0 的更新内容，包括新增功能、Bug 修复、测试和贡献者体验、开发者体验以及依赖项和维护等方面。新增功能包括支持在 import.meta 中使用解构赋值、支持带有 AwaitExpression 的解构赋值的树摇、引入 errorsSpace 和 warningsSpace 以获得更可读的跟踪信息等。Bug 修复主要涉及 CSS 相关问题、语法错误、模块 ID 分配等。此外，还对测试用例进行了完善，优化了开发者体验，并更新了一些依赖项。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deno vs. Node：没有人准备好迎接这个变化 | .cult by Honeypot]]></title>
        <id>https://cult.honeypot.io/reads/deno-vs-node-main-differences/</id>
        <link href="https://cult.honeypot.io/reads/deno-vs-node-main-differences/"/>
        <updated>2023-04-21T00:30:49.371Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cult.honeypot.io/reads/deno-vs-node-main-differences/">Deno vs. Node: No One is Ready for the Move | .cult by Honeypot</a></p><p><strong>概要：</strong></p><p>本文介绍了 Node.js 和 Deno 两个 JavaScript 运行环境的比较。Node.js 是一个流行的服务器端、开源、跨平台的 JavaScript 运行环境，自 2009 年以来一直占据着 Web 开发世界的主导地位。它专注于事件驱动的 HTTP 服务器，并使用单线程的事件循环处理请求。与大多数竞争对手不同的是，Node.js 基于回调函数的扩展机制可以在最小内存使用下处理更多的请求。相比之下，Deno 在设计上有所改进，提供了更安全的框架和现代特性，由 Node.js 的创始人 Ryan Dahl 推出。然而，尽管 Deno 解决了 Node.js 的一些设计缺陷，但采用 Deno 的速度非常缓慢，大多数开发人员仍然满意于 Node.js。本文将探讨这种现象背后的原因，并对 Node.js 和 Deno 进行比较，从第三方包管理、API、安全性和 TypeScript 支持等方面进行分析。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Rust 1.69.0 | Rust 博客]]></title>
        <id>https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html</id>
        <link href="https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html"/>
        <updated>2023-04-21T00:20:26.179Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html">Announcing Rust 1.69.0 | Rust Blog</a></p><p><strong>概要：</strong></p><p>Rust 1.69.0 版本发布，包含 3000 多个提交和 500 多个贡献者的小改进。其中，Cargo 现在建议自动修复一些警告，支持自动修复一些简单的 Clippy 警告。为了吸引更多关注，当检测到可以自动修复的警告时，Cargo 将建议运行 cargo fix 或 cargo clippy --fix。此外，为了提高编译速度，默认情况下不再在构建脚本中包含调试信息。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Vite 4.3。]]></title>
        <id>https://vitejs.dev/blog/announcing-vite4-3.html</id>
        <link href="https://vitejs.dev/blog/announcing-vite4-3.html"/>
        <updated>2023-04-20T14:49:02.877Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vitejs.dev/blog/announcing-vite4-3.html">Announcing Vite 4.3</a></p><p><strong>概要：</strong></p><p>Vite 4.3 发布，主要改进了开发服务器的性能。该版本优化了解析逻辑，改进了热路径，并实现了智能缓存，以查找 package.json、TS 配置文件和已解决的 URL。与 Vite 4.2 相比，这次更新在各方面都有速度提升。此外，该团队正在开发一个官方基准测试工具，以获取每个 Pull Request 的性能指标，并通过 vite-plugin-inspect 提供更多的性能相关功能来帮助用户识别应用程序的瓶颈。明年他们将发布 Vite 5，这将是今年唯一的 Vite 主要版本，同时也会放弃对 Node.js 14 和 16 的支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 npm 包 provenance | GitHub 博客]]></title>
        <id>https://github.blog/2023-04-19-introducing-npm-package-provenance/</id>
        <link href="https://github.blog/2023-04-19-introducing-npm-package-provenance/"/>
        <updated>2023-04-20T07:15:21.619Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-04-19-introducing-npm-package-provenance/">Introducing npm package provenance | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub has added a feature to its Actions tool that enables developers to publish provenance alongside their npm projects. The feature provides a verifiable link between a package and its source repository, as well as the build instructions used to publish it. The aim is to increase trust in open source projects by enabling developers to ensure the integrity of their software supply chain. The Supply-chain Levels for Software Artifacts (SLSA) specification was created for this purpose and is being used for GitHub's npm provenance statements. The company also requires packages to be built on a trusted CI/CD platform.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何编写类型安全的 CSS 模块 - LogRocket 博客]]></title>
        <id>http://blog.logrocket.com/write-type-safe-css-modules/</id>
        <link href="http://blog.logrocket.com/write-type-safe-css-modules/"/>
        <updated>2023-04-20T04:51:28.985Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="http://blog.logrocket.com/write-type-safe-css-modules/">How to write type-safe CSS Modules - LogRocket Blog</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 TypeScript 自动化 CSS Modules 类型定义。CSS Modules 提供了一种在现代 Web 应用程序中编写模块化和作用域 CSS 样式的方法，但是类名在运行时生成并且在构建之间更改，因此很难以类型安全的方式使用它们。手动创建每个 CSS Module 的类型定义文件更新繁琐，容易出错。本文介绍了如何使用 typed-css-modules 包自动生成类型定义，并提供脚本来验证生成的类型是否是最新的。通过自动化这些过程，可以减少开发人员对类型系统的不信任感，让团队专注于构建优秀的产品。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 20 现已推出！| Node.js]]></title>
        <id>https://nodejs.org/en/blog/announcements/v20-release-announce</id>
        <link href="https://nodejs.org/en/blog/announcements/v20-release-announce"/>
        <updated>2023-04-20T04:50:59.309Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nodejs.org/en/blog/announcements/v20-release-announce">Node.js 20 is now available! | Node.js</a></p><p><strong>概要：</strong></p><p>Node.js 20 发布了，其中包括了新的 Node.js 权限模型、同步 import.meta.resolve、稳定的测试运行器、更新到 V8 JavaScript 引擎 11.3 版本和 Ada 到 2.0 等。此次更新还包括对基础部分的改进，如 URL、fetch () 和 EventTarget 等。值得注意的是，Permission Model 是一项实验性机制，用于在执行期间限制对特定资源的访问。该项目继续在多个领域取得进展，许多新功能和修复已流入现有的 LTS 版本中。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[马克斯・莱特尔]]></title>
        <id>https://maxleiter.com/blog/build-a-blog-with-nextjs-13</id>
        <link href="https://maxleiter.com/blog/build-a-blog-with-nextjs-13"/>
        <updated>2023-04-20T04:28:00.583Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://maxleiter.com/blog/build-a-blog-with-nextjs-13">Max Leiter</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Next.js 13 和 React Server Components 构建博客，并提供了实际示例。文章包括设置项目、文件结构、动态路由、获取和呈现 Markdown、SEO、部署等内容。作者还介绍了如何使用 next-mdx-remote 和 Bright 进行语法高亮。本文旨在帮助读者快速搭建自己的博客，并鼓励读者进行自己的实验和探索。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[成为 Astro 维护者]]></title>
        <id>https://www.elian.codes/blog/23-04-12-becoming-an-astro-maintainer/</id>
        <link href="https://www.elian.codes/blog/23-04-12-becoming-an-astro-maintainer/"/>
        <updated>2023-04-20T04:27:40.850Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.elian.codes/blog/23-04-12-becoming-an-astro-maintainer/">Becoming an Astro maintainer</a></p><p><strong>概要：</strong></p><p>本文介绍了作者如何开始参与开源，并最终成为 Astro 的维护者。作者分享了自己的经验和故事，包括加入 Astro Discord 社区、提交第一个 PR 和发表有关 Astro 的演讲等。作者还提出了自己作为 Astro 维护者的目标，包括推出大使计划、改进文档和优化开发体验等。最后，作者表示很高兴能够成为 Astro 社区的一员，并希望在更广泛的开源领域中产生积极影响。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何训练自己的大型语言模型]]></title>
        <id>https://blog.replit.com/llm-training</id>
        <link href="https://blog.replit.com/llm-training"/>
        <updated>2023-04-20T04:23:36.827Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.replit.com/llm-training">How to train your own Large Language Models</a></p><p><strong>概要：</strong></p><p>Replit 介绍了如何使用 Databricks、Hugging Face 和 MosaicML 训练大型语言模型（LLM）。该公司投资了大量基础设施来从头开始训练自己的 LLM，以实现定制化、减少依赖和成本效益。他们使用 The Stack 作为主要数据源，并使用 Databricks 进行数据处理。在令牌化和词汇训练之前，他们使用自定义词汇表。最后，他们使用 MosaicML 进行模型训练，并使用 NVIDIA 的 FasterTransformer 和 Triton Server 加速推理过程。 Replit 表示，他们计划在未来的博客文章中深入探讨这些步骤的详细信息。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 v10.0.0・immerjs/immer]]></title>
        <id>https://github.com/immerjs/immer/releases/tag/v10.0.0</id>
        <link href="https://github.com/immerjs/immer/releases/tag/v10.0.0"/>
        <updated>2023-04-19T00:42:12.350Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/immerjs/immer/releases/tag/v10.0.0">Release v10.0.0 · immerjs/immer</a></p><p><strong>概要：</strong></p><p>Immer 10 发布了，支持现代浏览器，不再支持 UMD 构建和 Promise-based reducers。默认情况下忽略纯对象上的 getter 和 setter，提供了显著的性能提升。ES5 模式已被删除，缩短 JSON 数组长度现在会生成删除补丁。此外，Immer 现在是一个 ESM 包，可以直接在浏览器中导入。对于迁移，如果有任何 enableES5 () 调用，则不进行迁移，使用 getter/setter icmw 纯对象时，在启动时调用 useStrictShallowCopy (true)，替换所有默认导入，将 import produce from "immer" 替换为 import {produce} from "immer"，将所有对 enableAllPlugins () 的调用替换为 enablePatches (); enableMapSet ()。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node v20.0.0]]></title>
        <id>https://nodejs.org/en/blog/release/v20.0.0</id>
        <link href="https://nodejs.org/en/blog/release/v20.0.0"/>
        <updated>2023-04-19T00:09:46.699Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nodejs.org/en/blog/release/v20.0.0">Node v20.0.0</a></p><p><strong>概要：</strong></p><p>Node.js v20.0.0 (Current)更新了很多功能。Permission Model是其中一个实验性功能，它允许开发人员在程序执行期间限制对特定资源（例如文件系统操作、子进程生成和工作线程创建）的访问。通过启用标志--experimental-permission，可以限制对所有可用权限的访问。使用此功能，开发人员可以防止应用程序访问或修改敏感数据或运行潜在有害代码。此外，ESM hooks现在在专用线程上运行，与主线程隔离，确保加载器和应用程序代码之间没有交叉污染。V8引擎更新到11.3版本，增加了一些新的功能，例如String.prototype.isWellFormed和toWellFormed、Resizable ArrayBuffer和growable SharedArrayBuffer等。测试运行器模块已经被标记为稳定模块，而不再是实验性模块。URL解析器Ada 2.0也得到了升级，带来了显著的性能提升。ARM64 Windows现在也得到了官方支持。同时，url.parse()将不再接受端口号不是数字的URL，这可能会导致意外输入的主机名欺骗。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 TypeScript 5.1 Beta - TypeScript。]]></title>
        <id>https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-beta/</id>
        <link href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-beta/"/>
        <updated>2023-04-19T00:09:46.499Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-beta/">Announcing TypeScript 5.1 Beta - TypeScript</a></p><p><strong>概要：</strong></p><p>TypeScript 5.1 beta has been released, featuring easier implicit returns for undefined-returning functions and unrelated types for getters and setters. The release also includes decoupled type-checking between JSX elements and JSX tag types, namespaced JSX attributes and the ability to edit multiple locations at the same time automatically. TypeScript now provides snippet completions when typing out a @param tag in both TypeScript and JavaScript files. The release also features optimisations including avoiding unnecessary type instantiation and reduced calls into scanner for JSDoc parsing. However, ES2020 and Node.js 14.17 are now the minimum runtime requirements.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个 README 模板 - 带有自动生成的目录・Matthias Ott - 用户体验设计师]]></title>
        <id>https://matthiasott.com/notes/a-readme-template-with-an-automatically-generated-table-of-contents</id>
        <link href="https://matthiasott.com/notes/a-readme-template-with-an-automatically-generated-table-of-contents"/>
        <updated>2023-04-18T08:11:21.420Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://matthiasott.com/notes/a-readme-template-with-an-automatically-generated-table-of-contents">A README Template – With an Automatically Generated Table of Contents · Matthias Ott – User Experience Designer</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了如何在项目中编写 README 文件，作者提供了一个包含重要部分的模板，并且还介绍了一个自动生成目录的工具 DocToc。此外，作者还推荐了一个名为 Readme.so 的编辑器，可以通过拖放和调整文本来创建个性化的 README 文件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - yoavbls/pretty-ts-errors：🔵 在 VSCode 中使 TypeScript 错误更漂亮和易读 🎀]]></title>
        <id>https://github.com/yoavbls/pretty-ts-errors</id>
        <link href="https://github.com/yoavbls/pretty-ts-errors"/>
        <updated>2023-04-18T07:00:29.280Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/yoavbls/pretty-ts-errors">GitHub - yoavbls/pretty-ts-errors: 🔵 Make TypeScript errors prettier and human-readable in VSCode 🎀</a></p><p><strong>概要：</strong></p><p>这是一个名为“Pretty TypeScript Errors”的Visual Studio Code扩展，旨在让TypeScript错误变得更加美观和易于阅读。当类型的复杂性增加时，TypeScript错误会变得越来越混乱。这个扩展能帮助您更好地理解错误信息。主要功能包括：为错误信息中的类型提供语法高亮，支持深色和浅色主题；在错误信息中的类型旁边提供一个按钮，可以跳转到相关类型声明；提供一个按钮，可以将您导航到typescript.tv，那里有详细的解释，有时还有视频；提供一个按钮，可以将您导航到ts-error-translator，那里可以用简单的英语阅读错误。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECMAScript 2023 有什么新特性 | pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/whats-new-in-ecmascript-2023/</id>
        <link href="https://pawelgrzybek.com/whats-new-in-ecmascript-2023/"/>
        <updated>2023-04-18T06:01:20.978Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2023/">What's new in ECMAScript 2023 | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>JavaScript 的新功能列表已经确定，最终版本的 ECMAScript 规范预计将于 6 月底发布。这些新功能包括在 Array 和 TypedArray 原型上添加 findLast () 和 findLastIndex () 方法、标准化 Hashbang 语法、允许使用符号作为 WeakMap 键以及在 Array.prototype 上添加返回新副本的方法等。这些功能都已达到第 4 阶段，并预计将包含在即将发布的 ECMAScript 版本中。</p>]]></content>
    </entry>
</feed>
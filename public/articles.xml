<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-03-30T09:50:55.048Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[成为一名千倍工程师或者不惜一切尝试。]]></title>
        <id>https://kadekillary.work/posts/1000x-eng/</id>
        <link href="https://kadekillary.work/posts/1000x-eng/"/>
        <updated>2023-03-30T00:58:12.217Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://kadekillary.work/posts/1000x-eng/">become a 1000x engineer or die tryin'</a></p><p><strong>概要：</strong></p><p>本文介绍如何通过一系列命令行包装函数来使用 OpenAI API 提高程序员的生产力。作者首先介绍了如何获取 OpenAI API 密钥，然后演示了如何使用 API 来回答各种问题、生成数据集、创建图像等。作者认为，未来的开发者生产力将会是一个重要的竞争优势，而采用借助人工智能的工作流程可能会更加高效。虽然这并不意味着程序员将被替代，但它提供了一种解决模糊领域中更大问题的有趣新方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布罗马 v12 版本发布]]></title>
        <id>https://rome.tools/blog/2023/03/28/rome12/</id>
        <link href="https://rome.tools/blog/2023/03/28/rome12/"/>
        <updated>2023-03-30T00:31:32.694Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://rome.tools/blog/2023/03/28/rome12/">Announcing Rome v12</a></p><p><strong>概要：</strong></p><p>Rome 版本 12 已推出，新增了 JSON 支持、新的 lint 规则、导入排序等功能。Rome 现在支持 JSON 文件，用户可以通过 CLI 或 LSP 格式化 JSON 文件，并在解析 JSON 文件时使用 Rome 的诊断工具。此外，Rome 还支持 TypeScript 4.7 和 TypeScript 5.0 的所有新功能。该版本还提供了导入排序功能，用户可以通过配置文件控制该功能。Rome 还增强了配置文件的诊断和恢复功能，以及自动发现配置文件和指定配置文件路径的功能。该版本还添加了新的 lint 规则和更多配置选项。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 Create React App (CRA) 迁移到 Vite]]></title>
        <id>https://www.robinwieruch.de/vite-create-react-app/</id>
        <link href="https://www.robinwieruch.de/vite-create-react-app/"/>
        <updated>2023-03-29T09:29:25.243Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.robinwieruch.de/vite-create-react-app/">Migrate to Vite from Create React App (CRA)</a></p><p><strong>概要：</strong></p><p>本文介绍了如何将现有的 Create React App（CRA）项目迁移到 Vite，以创建一个现代的 React 单页应用程序。作者提供了一份快速迁移指南，包括安装 Vite 和相关依赖、更改 package.json 文件中的脚本、重命名 JSX 文件的扩展名等步骤。此外，如果需要保留 ESLint、TypeScript、react-testing-library 等配置，作者还提供了相应的教程链接。最后，作者列举了一些可能出现的问题及其解决方案。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么工程师需要写作]]></title>
        <id>https://www.developing.dev/p/why-engineers-need-to-write</id>
        <link href="https://www.developing.dev/p/why-engineers-need-to-write"/>
        <updated>2023-03-29T02:58:58.691Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developing.dev/p/why-engineers-need-to-write">Why Engineers Need To Write</a></p><p><strong>概要：</strong></p><p>本文讨论了写作在软件工程中的重要性。软件工程师需要写技术问题、代码评论和设计文档等，因为编写软件是协作的过程。优秀的写作能力可以提高软件工程师的效率和影响力。此外，写作还是影响他人最可扩展的方式之一。即使未来 AI 工具可以代替我们写作，写作仍然有价值，因为它可以强制将思维转化为连贯的逻辑叙述，同时也能够激发更多的创意。因此，写作对于软件工程师来说是一项必备技能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[v3.3：扩展的颜色调色板、ESM/TS 支持、逻辑属性等 - Tailwind CSS]]></title>
        <id>https://tailwindcss.com/blog/tailwindcss-v3-3</id>
        <link href="https://tailwindcss.com/blog/tailwindcss-v3-3"/>
        <updated>2023-03-29T02:03:43.886Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tailwindcss.com/blog/tailwindcss-v3-3">Tailwind CSS v3.3: Extended color palette, ESM/TS support, logical properties, and more - Tailwind CSS</a></p><p><strong>概要：</strong></p><p>Tailwind CSS 发布了 3.3 版本，带来了用户一直期待的一些新功能以及一些未知但有用的新功能。其中包括扩展颜色调色板、ESM 和 TypeScript 支持、简化 RTL 支持、精细调整渐变颜色停止位置、一键截断多行文本、新的行高修改器、无 var () 的 CSS 变量、可配置字体变量设置、新的列表样式图像工具和连字符工具等。此外，该版本还添加了更多的逻辑属性实用程序，以便在 LTR 和 RTL 语言之间进行样式设置。升级项目只需从 npm 安装最新版本即可。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个完整的视觉指南，帮助理解 Node.js 事件循环]]></title>
        <id>https://www.builder.io/blog/visual-guide-to-nodejs-event-loop</id>
        <link href="https://www.builder.io/blog/visual-guide-to-nodejs-event-loop"/>
        <updated>2023-03-29T01:11:57.940Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/visual-guide-to-nodejs-event-loop">A Complete Visual Guide to Understanding the Node.js Event Loop</a></p><p><strong>概要：</strong></p><p>本文介绍了 Node.js 事件循环的视觉指南。文章首先回顾了 JavaScript 中的异步编程，然后介绍了 Node.js 运行时和其核心组件之一的 libuv 库。接着，文章解释了在 Node.js 运行时中代码执行的过程，并探讨了 libuv 如何处理异步操作。最后，文章详细介绍了事件循环的工作原理和不同队列的优先级顺序。通过这篇文章，读者可以更好地理解 Node.js 事件循环，从而编写出更高效的应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 和 Rust：全栈开发的创新方法]]></title>
        <id>https://joshmo.hashnode.dev/nextjs-and-rust-an-innovative-approach-to-full-stack-development</id>
        <link href="https://joshmo.hashnode.dev/nextjs-and-rust-an-innovative-approach-to-full-stack-development"/>
        <updated>2023-03-29T01:11:41.118Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://joshmo.hashnode.dev/nextjs-and-rust-an-innovative-approach-to-full-stack-development">Next.js and Rust: An Innovative Approach to Full-Stack Development</a></p><p><strong>概要：</strong></p><p>Shuttle, a cloud development platform, has released a Node.js CLI package that allows users to quickly create an application with a Rust backend using Axum, a popular Rust web framework. The article focuses on the Rust side of the app, which is a notes app with a login portal that can register users and reset passwords. The frontend uses React.js/Next.js. Shuttle simplifies deployment by allowing users to define infrastructure directly in their code without the need for external files. The article provides step-by-step instructions on how to set up the backend, including creating a router and adding CRUD functionality. Deployment with shuttle is also covered.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 GitHub Actions 扩展适用于 VS Code | GitHub 博客]]></title>
        <id>https://github.blog/2023-03-28-announcing-the-github-actions-extension-for-vs-code/</id>
        <link href="https://github.blog/2023-03-28-announcing-the-github-actions-extension-for-vs-code/"/>
        <updated>2023-03-29T01:07:07.609Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-03-28-announcing-the-github-actions-extension-for-vs-code/">Announcing the GitHub Actions extension for VS Code | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub 发布了官方的 GitHub Actions VS Code 扩展程序的公共测试版。该扩展程序支持编写和编辑工作流程，并帮助用户管理工作流程运行，无需离开 IDE。使用该扩展程序，用户可以在不离开编辑器的情况下管理工作流程，轻松监控存储库中的工作流程运行，取消和重新运行它们，或者为手动触发的工作流程触发新的运行。此外，用户还可以列出所有受支持级别（组织、存储库和环境）的可用密钥和变量。扩展程序提供了语法高亮、集成文档、验证和代码完成等功能，以提高编辑工作流程的体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Nuxt DevTools・Nuxt]]></title>
        <id>https://nuxt.com/blog/introducing-nuxt-devtools</id>
        <link href="https://nuxt.com/blog/introducing-nuxt-devtools"/>
        <updated>2023-03-28T15:22:48.486Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nuxt.com/blog/introducing-nuxt-devtools">Introducing Nuxt DevTools · Nuxt</a></p><p><strong>概要：</strong></p><p>Nuxt DevTools 是一种新工具，旨在帮助开发人员了解 Nuxt 应用程序并进一步提高开发体验。该工具提供了更好的透明度，可以找到性能瓶颈并帮助您管理应用程序和配置。它作为实验性模块发布，并在安装后添加一个小图标，点击它将打开 DevTools 面板。该工具包括许多功能，如页面、组件、导入、模块、挂钩、应用程序配置、负载和数据、终端等。Nuxt DevTools 还可以扩展，允许模块贡献其自己的视图，以提供其集成的交互式数据和游乐场。未来，Nuxt DevTools 计划添加更多功能，同时探索以更直观和有趣的方式呈现数据的方法。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 v8.0.0・pnpm/pnpm]]></title>
        <id>https://github.com/pnpm/pnpm/releases/tag/v8.0.0</id>
        <link href="https://github.com/pnpm/pnpm/releases/tag/v8.0.0"/>
        <updated>2023-03-28T14:23:03.802Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/pnpm/pnpm/releases/tag/v8.0.0">Release v8.0.0 · pnpm/pnpm</a></p><p><strong>概要：</strong></p><p>pnpm 发布了最新版本 v8，其中包括一些重要的更改和更新。首先，不再支持 Node.js 14，但是 pnpm 会随着 Node.js 一起打包，因此无论您安装哪个 Node.js 版本，pnpm 都将使用必要的 Node.js 运行时。其次，大多数配置更改与对等依赖关系有关，其中 auto-install-peers、dedupe-peer-dependents 和 resolve-peers-from-workspace-root 等设置已默认启用。此外，还采用了 Lockfile v6，该格式通过从软件包 ID 中删除哈希来提高锁定文件的可读性，并对导入器部分中的字段进行了一些重新排列。同时，pnpm-lock.yaml 文件也更加抗 git 合并冲突。最后，直接依赖项现在会被去重，如果一个依赖项同时存在于项目和工作区根目录中，则只会链接到工作区根目录。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 Svelte 的想法]]></title>
        <id>https://tyhopp.com/notes/thoughts-on-svelte</id>
        <link href="https://tyhopp.com/notes/thoughts-on-svelte"/>
        <updated>2023-03-28T04:41:01.088Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tyhopp.com/notes/thoughts-on-svelte">Thoughts on Svelte</a></p><p><strong>概要：</strong></p><p>本文介绍了作者在一个月内使用 Svelte 和 SvelteKit 构建个人 RSS 阅读器的经验，并分享了对 Svelte 的看法。作者认为 Svelte 的组件格式、内置存储和事件分发 API 是其优点，但反应语句、等待块和过渡动画 API 则是其缺点。作者表示，Svelte 适合个人项目，但可能不适合大型企业项目。最后，作者更新了一些评论，解决了对过渡动画 API 的疑虑。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 漫游 tabindex]]></title>
        <id>https://www.joshuawootonn.com/react-roving-tabindex</id>
        <link href="https://www.joshuawootonn.com/react-roving-tabindex"/>
        <updated>2023-03-28T02:36:10.958Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshuawootonn.com/react-roving-tabindex">React roving tabindex</a></p><p><strong>概要：</strong></p><p>本文介绍了 roving tabindex 的概念，即在组内跟踪焦点以便记住上一个聚焦的元素。作者使用 React 创建了一个按钮列表，并通过添加键盘导航来实现 roving tabindex 功能。文章详细讲解了如何从列表中获取元素顺序、如何在 onKeyDown 中找到当前焦点元素的索引并进行下一步操作，以及如何将状态移动到 context 中以实现可重用性等问题。最后，作者还提到了一些需要注意的地方，例如在 Safari 中 onClick 事件不会触发 onFocus 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建 Ghostwriter 聊天程序]]></title>
        <id>https://blog.replit.com/ghostwriter-building</id>
        <link href="https://blog.replit.com/ghostwriter-building"/>
        <updated>2023-03-27T16:33:36.516Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.replit.com/ghostwriter-building">Building Ghostwriter Chat</a></p><p><strong>概要：</strong></p><p>Replit 推出了一款名为 Ghostwriter Chat 的人工智能（AI）辅助编程工具。Ghostwriter Chat 是一个基于大型语言模型（LLM）的聊天应用程序，可帮助开发人员在不离开 IDE 的情况下解决问题。该工具可以利用文件上下文、聊天历史记录和程序输出等信息来帮助用户编写代码、回答问题或调试错误。Ghostwriter Debugger 是 Replit 的另一个 AI 工具，可在出现错误时自动警告用户，并允许单击即可进行调试。随着 AI 和 LLMs 变得更加强大，Ghostwriter Chat 将继续改进，未来版本将变得更加智能、更快、更强大。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ChatGPT + 代码解释器 = 魔法]]></title>
        <id>https://andrewmayneblog.wordpress.com/2023/03/23/chatgpt-code-interpreter-magic/</id>
        <link href="https://andrewmayneblog.wordpress.com/2023/03/23/chatgpt-code-interpreter-magic/"/>
        <updated>2023-03-27T06:26:08.425Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://andrewmayneblog.wordpress.com/2023/03/23/chatgpt-code-interpreter-magic/">ChatGPT + Code Interpreter = Magic</a></p><p><strong>概要：</strong></p><p>OpenAI 正在测试在 ChatGPT 中运行代码和使用第三方插件的能力。OpenAI 宣布正在为 ChatGPT 开发插件，以扩展其功能。插件范围从像 WolframAlpha 和 OpenTable 这样的第三方工具，到我们的浏览插件和代码解释器，可以生成代码、运行代码、上传和下载从 csv 数据到图像的文件，并在 ChatGPT 界面内评估输出。目前，代码解释器使用 Python 和一小部分库运行。除了生成代码外，代码解释器还可以分析输出并在另一个函数中使用它。此外，ChatGPT 还可以分析数据（如电子表格），然后执行诸如制图之类的函数，因此对于编码和研究都是非常强大的工具。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 Web SQL 到 SQLite Wasm：数据库迁移指南 - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/en/blog/from-web-sql-to-sqlite-wasm/</id>
        <link href="https://developer.chrome.com/en/blog/from-web-sql-to-sqlite-wasm/"/>
        <updated>2023-03-25T00:01:43.981Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/en/blog/from-web-sql-to-sqlite-wasm/">From Web SQL to SQLite Wasm: the database migration guide - Chrome Developers</a></p><p><strong>概要：</strong></p><p>本文介绍了如何将现有的 Web SQL 数据库迁移到基于 SQLite 数据库、编译为 Web Assembly（Wasm）并由 Origin Private File System 支持的 SQLite Wasm。作者提供了四个步骤，包括将 Web SQL 数据库翻译成 SQL 语句、导入数据到 SQLite Wasm、释放 Web SQL 存储空间以及在迁移后使用数据。通过这种方式，用户不会注意到他们的数据已经被迁移到 SQLite Wasm 中，并且不再存在于 Web SQL 中。虽然这个过程可能需要一些初始努力，但更强大、灵活和未来可扩展的数据库解决方案的好处使得它值得投资。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新的 React 文档似乎假装单页面应用程序不再存在 | Wasp]]></title>
        <id>https://wasp-lang.dev/blog/2023/03/17/new-react-docs-pretend-spas-dont-exist</id>
        <link href="https://wasp-lang.dev/blog/2023/03/17/new-react-docs-pretend-spas-dont-exist"/>
        <updated>2023-03-24T15:27:16.772Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://wasp-lang.dev/blog/2023/03/17/new-react-docs-pretend-spas-dont-exist">New React docs pretend SPAs don't exist anymore | Wasp</a></p><p><strong>概要：</strong></p><p>React 发布了新文档，网址为 https://react.dev/。虽然它看起来很棒，并且有很多改进，但引起社区关注的一个部分是 “开始一个新的 React 项目”。强烈建议启动新的 React 项目的方法是使用 Next.js 等框架，而传统的使用打包程序（如 Vite 或 CRA）的路线则相当不被推荐。Next.js 是一个很棒的框架，其受欢迎程度的上升在很大程度上归功于通过服务器端渲染（SSR）实现 SEO 优化的回归。对于依赖于 SEO 的静态站点和页面，使用提供 SSR 的框架确实是有意义的。但是，对于典型的单页应用程序（SPA）呢？那些生活在认证后面（根本不需要 SEO）的仪表板式工具，以及 React 最初设计的应用程序，仍然存在。新的 React 文档 - 使用框架，除非您的应用程序具有 “异常” 约束新文档对于在启动新的 React 项目时使用框架提出了一个相当强烈的主张。即使您阅读了 “我可以在没有框架的情况下使用 React” 部分（默认情况下隐藏在折叠切换后面），您也必须经过一堵劝说您不使用框架是个坏主意的墙。仅在最后，才提到其他选项，例如 Vite 和 Parcel：即使如此，在允许您 “不使用” 框架之前，您首先必须承认您的应用程序具有异常约束（并且没有给出任何可能的示例）。感觉就像你在所有警告的情况下做这件事</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过 WebAssembly 使用 Pages 功能，您可以选择任何语言。]]></title>
        <id>https://blog.cloudflare.com/pages-functions-with-webassembly/</id>
        <link href="https://blog.cloudflare.com/pages-functions-with-webassembly/"/>
        <updated>2023-03-24T14:51:04.691Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/pages-functions-with-webassembly/">Use the language of your choice with Pages Functions via WebAssembly</a></p><p><strong>概要：</strong></p><p>Cloudflare 宣布支持 WebAssembly，允许开发者使用除 JavaScript 以外的其他语言构建 Pages Functions 项目。WebAssembly 是一种类似汇编的低级语言，可实现接近本地性能的运行，并提供 C/C++、C# 或 Rust 等编程语言的编译目标，使它们可以与 JavaScript 一起运行。在 Cloudflare Pages Functions 中，WebAssembly 模块的导入方式与 Workers 类似，用户可以将.wasm 文件作为 WebAssembly 模块导入，然后直接从 Functions 中使用。这项工作还支持导入文本和二进制模块类型，这些非标准化模块对于需要导入原始文本块（如 HTML 文件）或原始数据块（如图像）的用户非常有用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 ts-node 迁移到 Bun | johnnyreilly]]></title>
        <id>https://johnnyreilly.com/migrating-from-ts-node-to-bun</id>
        <link href="https://johnnyreilly.com/migrating-from-ts-node-to-bun"/>
        <updated>2023-03-24T04:20:05.669Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://johnnyreilly.com/migrating-from-ts-node-to-bun">Migrating from ts-node to Bun | johnnyreilly</a></p><p><strong>概要：</strong></p><p>本文介绍了如何将一个使用 ts-node 编写的控制台应用程序迁移到 Bun，以及在迁移过程中遇到的一些问题和解决方案。作者发现 Bun 比 ts-node 快 50%，并且迁移过程相对容易。他认为这让他对 Bun 充满信心，并期待未来更多地使用它。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[加速 JavaScript 生态系统 - npm 脚本]]></title>
        <id>https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-4/</id>
        <link href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-4/"/>
        <updated>2023-03-24T04:19:12.641Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-4/">Speeding up the JavaScript ecosystem - npm scripts</a></p><p><strong>概要：</strong></p><p>本文介绍了如何优化 JavaScript 中常用的 “npm scripts”，以减少其约 400 毫秒的开销。作者通过分析 npm CLI 的代码结构，发现大部分时间都花费在加载组成 npm CLI 的模块上。作者通过惰性加载、减小模块图等方式，将运行 npm scripts 的时间从 400 毫秒降至 22 毫秒。作者指出，JavaScript 工具中普遍存在的问题是没有简便的方法来缩短模块图，因此可以考虑在发布时将代码打包，以减少加载时间。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过针对高密度显示进行优化，将图像大小减半。]]></title>
        <id>https://jakearchibald.com/2021/serving-sharp-images-to-high-density-screens/</id>
        <link href="https://jakearchibald.com/2021/serving-sharp-images-to-high-density-screens/"/>
        <updated>2023-03-24T04:18:06.088Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jakearchibald.com/2021/serving-sharp-images-to-high-density-screens/">Halve the size of images by optimising for high density displays</a></p><p><strong>概要：</strong></p><p>本文探讨了高密度屏幕的普及程度以及如何为其优化图像。作者指出，80% 的用户使用 DPR（设备像素比）为 1.5 或更高的屏幕，因此在设计网站时需要考虑到这一点。对于高密度屏幕，需要将图像压缩至用户的设备像素而不是 CSS 像素，以确保图像清晰度。作者提供了一种简单的方法来处理图像，即将最大尺寸乘以 2 并使用较低质量进行编码，以便在高密度屏幕上始终显示清晰的图像。此外，作者还介绍了一种更加完整的方法，包括使用 <picture> 和 < source > 标签，在不同的屏幕分辨率下提供不同的图像，并提供了示例代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vite 5・vitejs/vite・讨论 #12466]]></title>
        <id>https://github.com/vitejs/vite/discussions/12466</id>
        <link href="https://github.com/vitejs/vite/discussions/12466"/>
        <updated>2023-03-24T00:02:52.735Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/vitejs/vite/discussions/12466">Vite 5 · vitejs/vite · Discussion #12466</a></p><p><strong>概要：</strong></p><p>Vite 开始讨论下一个主要版本的需求，以收集来自下游生态系统和用户的早期反馈。Vite 5 将在 2023 年 9 月 11 日发布，支持 Node 14 和 Node 16，不支持非活动 LTS 版本（Node 15、Node 17、Node 19）。Vite 5 的开发将重点关注性能方面的改进，并可能引入一些破坏性变化。同时，Vite 还在考虑将 vite-node 移动到 Vite 核心作为 SSR 的替代方案。开发者可以在 Vite 5 的里程碑中跟踪新问题和 PR。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to get a cool NPM package name? 

如何获得一个酷炫的 NPM 包名？]]></title>
        <id>https://unix.bio/posts/how-to-get-npm-package-name</id>
        <link href="https://unix.bio/posts/how-to-get-npm-package-name"/>
        <updated>2023-03-23T15:11:49.813Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://unix.bio/posts/how-to-get-npm-package-name">怎样获得一个很酷的 NPM 包名</a></p><p><strong>概要：</strong></p><p>本文介绍了如何通过 NPM 的争议政策来申请将占位包的所有权转移给自己。对于长期没有更新或仅仅是占位的包，NPM 工作人员会在 4 周后自动将包的 owner 设置为申请者的用户名。申请者需要发送邮件至包的所有者并抄送 support@npmjs.com，并说明申请转移的原因、包名以及自己的 npm username。值得注意的是，如果要转移的包存在商标版权侵犯或者是占位问题，NPM 工作人员将立刻处理。关于组织与用户名的转移，组织可以直接联系 support@npmjs.com，而用户名的转移则被认为是 “几乎不可能的”。如果发现包含违反当地法律、不合适的内容、侵权等问题，可以举报滥用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您可能不需要的钩子]]></title>
        <id>https://reacttraining.com/blog/hooks-you-probably-dont-need</id>
        <link href="https://reacttraining.com/blog/hooks-you-probably-dont-need"/>
        <updated>2023-03-23T00:45:31.085Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://reacttraining.com/blog/hooks-you-probably-dont-need">Hooks You Probably Don't Need</a></p><p><strong>概要：</strong></p><p>本文介绍了 React Hooks 中一些不太常用的 Hook，包括 useDebugValue ()、useInsertionEffect ()、useImperativeHandle ()、useSyncExternalStore ()、useDeferredValue ()、useEffect () 和 useLayoutEffect ()。作者将这些 Hook 按照使用频率分为三类：不太可能使用的（红色）、偶尔会使用的（橙色）和根据具体情况而定的（绿色）。其中，useDebugValue () 用于在 DevTools 中为自定义 Hook 创建标签以进行调试；useInsertionEffect () 主要面向 CSS-in-JS 库开发者；useImperativeHandle () 用于限制或自定义向父组件暴露的 DOM 元素 API；useSyncExternalStore () 适用于第三方状态管理库或公开可变值和事件的浏览器 API；useDeferredValue () 用于显示过时内容并在加载新内容时延迟重新渲染 UI；useEffect () 用于处理渲染阶段的副作用，如数据获取；useLayoutEffect () 则用于在 UI 渲染前运行同步副作用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无限混音 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support</id>
        <link href="https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support"/>
        <updated>2023-03-23T00:39:59.131Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support">Remix without Limits – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel has announced an advanced integration with Remix, a server-rendered React framework. The integration allows developers to stream content dynamically using Node.js and Edge runtimes, build serverless APIs with Remix and a route loader, use powerful cache headers like stale-while-revalidate for advanced caching, and run data mutations inside Serverless or Edge Functions. The integration also supports both Node.js and Web/Edge-oriented runtimes on a per-route basis, enabling developers to take advantage of the best parts of both. Additionally, Vercel's Edge Network Cache supports caching loader responses and newer caching headers like stale-if-error.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实验室：我们正在进行的工作 ——2023 年 3 月 ——React]]></title>
        <id>https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023</id>
        <link href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023"/>
        <updated>2023-03-23T00:04:10.043Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023">React Labs: What We've Been Working On – March 2023 – React</a></p><p><strong>概要：</strong></p><p>React Labs 发布了最新的研究进展，包括 React Server Components、Asset Loading、Document Metadata、React Optimizing Compiler、Offscreen Rendering 和 Transition Tracing 等。其中，React Server Components 是由 React 团队设计的一种新的应用架构，它结合了服务器中心多页面应用程序的简单 “请求 / 响应” 模型和客户端中心单页面应用程序的无缝交互性，同时提供了一种新的组件类型 ——Server Components，它们可以在构建期间运行，也可以在服务器上运行，让您无需构建 API 即可访问数据层。另外，React Labs 还在开发 Suspense、Transition Tracing 等功能，以提高 React 的性能和用户体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[那么，您已经安装了 `fzf`。现在该怎么办？]]></title>
        <id>https://andrew-quinn.me/fzf/</id>
        <link href="https://andrew-quinn.me/fzf/"/>
        <updated>2023-03-22T15:41:43.724Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://andrew-quinn.me/fzf/">So you've installed `fzf`. Now what?</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 fzf 的工具，它是一个命令行模糊搜索工具，可以极大地提高 Linux 和 Windows 终端用户的效率。作者提到，fzf 的快捷键能够替代基础版本的 Ctrl+R，并且还有一些其他功能，例如 Alt+C 可以快速跳转目录，vi $(fzf) 可以模糊查找文件并打开编辑器等。此外，作者还介绍了另一个工具 rg，它是一个快速的递归 grep 工具，可以与 fzf 结合使用来进行模糊搜索文件内容。总之，fzf 和 rg 都是非常实用的命令行工具，值得一试。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Copilot X：AI 动力的开发者体验 | GitHub 博客]]></title>
        <id>https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/</id>
        <link href="https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/"/>
        <updated>2023-03-22T14:38:23.977Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/">GitHub Copilot X: The AI-powered developer experience | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub Copilot X 是 GitHub 的新一代 AI 辅助开发工具，它将 AI 引入整个开发生命周期中。除了自动完成注释和代码外，Copilot X 还支持聊天和语音交互，并在 pull requests、命令行和文档中提供 AI 支持。Copilot X 基于 OpenAI 的 GPT-4 模型，可以为开发人员生成单元测试、修复错误等。此外，Copilot X 还支持针对文档的 ChatGPT 接口，让开发人员能够快速获取关于 React、Azure Docs 和 MDN 等文档的答案。GitHub 希望通过 Copilot X 改变开发者的工作方式，提高其生产力和创造力。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 2023 年开始一个 React 项目]]></title>
        <id>https://www.robinwieruch.de/react-starter/</id>
        <link href="https://www.robinwieruch.de/react-starter/"/>
        <updated>2023-03-22T04:52:06.786Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.robinwieruch.de/react-starter/">How to start a React Project in 2023</a></p><p><strong>概要：</strong></p><p>本文介绍了几种新 React 项目的起始套件，包括 React with Vite、React with Next、React with Astro 等。作者对每种套件的优缺点、开发者所需技能水平以及针对 React 开发者提供的特性进行了分析，并给出了不同需求的三种解决方案。最后，文章总结了一些关于 React 起始项目的思考和建议。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务器首选框架 - HackMD]]></title>
        <id>https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di</id>
        <link href="https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di"/>
        <updated>2023-03-22T04:34:33.396Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di">Server First Framework - HackMD</a></p><p><strong>概要：</strong></p><p>该文章提出了一个名为 “Server First Framework” 的框架概念，预计将于 2023 年推出。作者认为，虽然过去十年的单页面应用程序（SPA）教会了我们很多东西，但我们现在携带了太多负担。设计面向服务器的框架时，要避免使用过多的同构倾向。

该框架的初始页面呈现与 Islands 框架非常相似。所有组件都是经过服务器渲染并发送到浏览器的。客户端组件道具被序列化，并启动任何资源内部的客户端组件。客户端组件被收集并且被水合（如果流式传输可用）。对于后续的导航，路由器将使用下一个 URL（包括当前 URL）请求服务器。服务器能够处理它以确定需要呈现哪些路由部分。同时，客户端请求下一个 URL 所需的所有 Islands 以加载代码。服务器仅呈现新路由部分，跳过呈现客户端组件，但仍然序列化道具。客户端接收响应，并能够使用 HTML 差异交换路由输出。在核心部分，变异遵循 MPA 的模式。您发送数据，服务器响应表示该更改的新标记。您可以将其视为表单提交。该请求响应下一页，因此处理程序可能会使用重定向 / 无效返回语法，即使它们都作为同一服务器响应的一部分进行处理。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编写你自己的响应式信号库]]></title>
        <id>https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/</id>
        <link href="https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/"/>
        <updated>2023-03-21T04:35:53.580Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/">Writing Your Own Reactive Signal Library</a></p><p><strong>概要：</strong></p><p>近来，前端领域出现了对细粒度反应性的新发现，这是一种通过使用三个主要原语：信号、效果和备忘录来构建反应式用户界面的风格。最近，我们看到像 Angular、Preact 和 Qwik 这样的框架在其现有框架中添加了信号。当然，SolidJS 是我选择的框架，创建者 Ryan Carniato 也引领了前端框架中信号的流行趋势。

什么是信号？

“信号” 这个名字并不特别描述性，所以它可能会让人感到有点困惑，不知道它提供了什么好处，以及它与 RxJS Observables 之类的东西有何不同。SolidJS 提供了一个很好的定义：

信号是事件发射器，它们保存订阅列表。每当它们的值发生变化时，它们就会通知其订阅者。

- SolidJS 文档

如果这不完全有意义，不用担心 —— 我们将通过编写自己的信号来学习！

为什么要创建自己的信号？

如果所有这些库都已经提供了信号原语，为什么我们要编写自己的信号呢？实际上，主要是作为一种学习体验！我不一定建议使用我们编写的内容来代替 Solid 等框架，因为它包含了针对不同边缘情况的更高级优化。相反，这种做法将帮助您更好地理解 Solid 和反应性的工作方式。

基础知识

对于我们的基本反应系统，我们将创建两个原语：createSignal 和 createEffect。备忘录（又称 createMemo）是反应性的第</p>]]></content>
    </entry>
</feed>
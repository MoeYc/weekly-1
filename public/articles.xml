<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-03-28T02:37:30.299Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[React 漫游 tabindex]]></title>
        <id>https://www.joshuawootonn.com/react-roving-tabindex</id>
        <link href="https://www.joshuawootonn.com/react-roving-tabindex"/>
        <updated>2023-03-28T02:36:10.958Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshuawootonn.com/react-roving-tabindex">React roving tabindex</a></p><p><strong>概要：</strong></p><p>本文介绍了 roving tabindex 的概念，即在组内跟踪焦点以便记住上一个聚焦的元素。作者使用 React 创建了一个按钮列表，并通过添加键盘导航来实现 roving tabindex 功能。文章详细讲解了如何从列表中获取元素顺序、如何在 onKeyDown 中找到当前焦点元素的索引并进行下一步操作，以及如何将状态移动到 context 中以实现可重用性等问题。最后，作者还提到了一些需要注意的地方，例如在 Safari 中 onClick 事件不会触发 onFocus 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建 Ghostwriter 聊天程序]]></title>
        <id>https://blog.replit.com/ghostwriter-building</id>
        <link href="https://blog.replit.com/ghostwriter-building"/>
        <updated>2023-03-27T16:33:36.516Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.replit.com/ghostwriter-building">Building Ghostwriter Chat</a></p><p><strong>概要：</strong></p><p>Replit 推出了一款名为 Ghostwriter Chat 的人工智能（AI）辅助编程工具。Ghostwriter Chat 是一个基于大型语言模型（LLM）的聊天应用程序，可帮助开发人员在不离开 IDE 的情况下解决问题。该工具可以利用文件上下文、聊天历史记录和程序输出等信息来帮助用户编写代码、回答问题或调试错误。Ghostwriter Debugger 是 Replit 的另一个 AI 工具，可在出现错误时自动警告用户，并允许单击即可进行调试。随着 AI 和 LLMs 变得更加强大，Ghostwriter Chat 将继续改进，未来版本将变得更加智能、更快、更强大。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ChatGPT + 代码解释器 = 魔法]]></title>
        <id>https://andrewmayneblog.wordpress.com/2023/03/23/chatgpt-code-interpreter-magic/</id>
        <link href="https://andrewmayneblog.wordpress.com/2023/03/23/chatgpt-code-interpreter-magic/"/>
        <updated>2023-03-27T06:26:08.425Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://andrewmayneblog.wordpress.com/2023/03/23/chatgpt-code-interpreter-magic/">ChatGPT + Code Interpreter = Magic</a></p><p><strong>概要：</strong></p><p>OpenAI 正在测试在 ChatGPT 中运行代码和使用第三方插件的能力。OpenAI 宣布正在为 ChatGPT 开发插件，以扩展其功能。插件范围从像 WolframAlpha 和 OpenTable 这样的第三方工具，到我们的浏览插件和代码解释器，可以生成代码、运行代码、上传和下载从 csv 数据到图像的文件，并在 ChatGPT 界面内评估输出。目前，代码解释器使用 Python 和一小部分库运行。除了生成代码外，代码解释器还可以分析输出并在另一个函数中使用它。此外，ChatGPT 还可以分析数据（如电子表格），然后执行诸如制图之类的函数，因此对于编码和研究都是非常强大的工具。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 Web SQL 到 SQLite Wasm：数据库迁移指南 - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/en/blog/from-web-sql-to-sqlite-wasm/</id>
        <link href="https://developer.chrome.com/en/blog/from-web-sql-to-sqlite-wasm/"/>
        <updated>2023-03-25T00:01:43.981Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/en/blog/from-web-sql-to-sqlite-wasm/">From Web SQL to SQLite Wasm: the database migration guide - Chrome Developers</a></p><p><strong>概要：</strong></p><p>本文介绍了如何将现有的 Web SQL 数据库迁移到基于 SQLite 数据库、编译为 Web Assembly（Wasm）并由 Origin Private File System 支持的 SQLite Wasm。作者提供了四个步骤，包括将 Web SQL 数据库翻译成 SQL 语句、导入数据到 SQLite Wasm、释放 Web SQL 存储空间以及在迁移后使用数据。通过这种方式，用户不会注意到他们的数据已经被迁移到 SQLite Wasm 中，并且不再存在于 Web SQL 中。虽然这个过程可能需要一些初始努力，但更强大、灵活和未来可扩展的数据库解决方案的好处使得它值得投资。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新的 React 文档似乎假装单页面应用程序不再存在 | Wasp]]></title>
        <id>https://wasp-lang.dev/blog/2023/03/17/new-react-docs-pretend-spas-dont-exist</id>
        <link href="https://wasp-lang.dev/blog/2023/03/17/new-react-docs-pretend-spas-dont-exist"/>
        <updated>2023-03-24T15:27:16.772Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://wasp-lang.dev/blog/2023/03/17/new-react-docs-pretend-spas-dont-exist">New React docs pretend SPAs don't exist anymore | Wasp</a></p><p><strong>概要：</strong></p><p>React 发布了新文档，网址为 https://react.dev/。虽然它看起来很棒，并且有很多改进，但引起社区关注的一个部分是 “开始一个新的 React 项目”。强烈建议启动新的 React 项目的方法是使用 Next.js 等框架，而传统的使用打包程序（如 Vite 或 CRA）的路线则相当不被推荐。Next.js 是一个很棒的框架，其受欢迎程度的上升在很大程度上归功于通过服务器端渲染（SSR）实现 SEO 优化的回归。对于依赖于 SEO 的静态站点和页面，使用提供 SSR 的框架确实是有意义的。但是，对于典型的单页应用程序（SPA）呢？那些生活在认证后面（根本不需要 SEO）的仪表板式工具，以及 React 最初设计的应用程序，仍然存在。新的 React 文档 - 使用框架，除非您的应用程序具有 “异常” 约束新文档对于在启动新的 React 项目时使用框架提出了一个相当强烈的主张。即使您阅读了 “我可以在没有框架的情况下使用 React” 部分（默认情况下隐藏在折叠切换后面），您也必须经过一堵劝说您不使用框架是个坏主意的墙。仅在最后，才提到其他选项，例如 Vite 和 Parcel：即使如此，在允许您 “不使用” 框架之前，您首先必须承认您的应用程序具有异常约束（并且没有给出任何可能的示例）。感觉就像你在所有警告的情况下做这件事</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过 WebAssembly 使用 Pages 功能，您可以选择任何语言。]]></title>
        <id>https://blog.cloudflare.com/pages-functions-with-webassembly/</id>
        <link href="https://blog.cloudflare.com/pages-functions-with-webassembly/"/>
        <updated>2023-03-24T14:51:04.691Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/pages-functions-with-webassembly/">Use the language of your choice with Pages Functions via WebAssembly</a></p><p><strong>概要：</strong></p><p>Cloudflare 宣布支持 WebAssembly，允许开发者使用除 JavaScript 以外的其他语言构建 Pages Functions 项目。WebAssembly 是一种类似汇编的低级语言，可实现接近本地性能的运行，并提供 C/C++、C# 或 Rust 等编程语言的编译目标，使它们可以与 JavaScript 一起运行。在 Cloudflare Pages Functions 中，WebAssembly 模块的导入方式与 Workers 类似，用户可以将.wasm 文件作为 WebAssembly 模块导入，然后直接从 Functions 中使用。这项工作还支持导入文本和二进制模块类型，这些非标准化模块对于需要导入原始文本块（如 HTML 文件）或原始数据块（如图像）的用户非常有用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 ts-node 迁移到 Bun | johnnyreilly]]></title>
        <id>https://johnnyreilly.com/migrating-from-ts-node-to-bun</id>
        <link href="https://johnnyreilly.com/migrating-from-ts-node-to-bun"/>
        <updated>2023-03-24T04:20:05.669Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://johnnyreilly.com/migrating-from-ts-node-to-bun">Migrating from ts-node to Bun | johnnyreilly</a></p><p><strong>概要：</strong></p><p>本文介绍了如何将一个使用 ts-node 编写的控制台应用程序迁移到 Bun，以及在迁移过程中遇到的一些问题和解决方案。作者发现 Bun 比 ts-node 快 50%，并且迁移过程相对容易。他认为这让他对 Bun 充满信心，并期待未来更多地使用它。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[加速 JavaScript 生态系统 - npm 脚本]]></title>
        <id>https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-4/</id>
        <link href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-4/"/>
        <updated>2023-03-24T04:19:12.641Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-4/">Speeding up the JavaScript ecosystem - npm scripts</a></p><p><strong>概要：</strong></p><p>本文介绍了如何优化 JavaScript 中常用的 “npm scripts”，以减少其约 400 毫秒的开销。作者通过分析 npm CLI 的代码结构，发现大部分时间都花费在加载组成 npm CLI 的模块上。作者通过惰性加载、减小模块图等方式，将运行 npm scripts 的时间从 400 毫秒降至 22 毫秒。作者指出，JavaScript 工具中普遍存在的问题是没有简便的方法来缩短模块图，因此可以考虑在发布时将代码打包，以减少加载时间。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过针对高密度显示进行优化，将图像大小减半。]]></title>
        <id>https://jakearchibald.com/2021/serving-sharp-images-to-high-density-screens/</id>
        <link href="https://jakearchibald.com/2021/serving-sharp-images-to-high-density-screens/"/>
        <updated>2023-03-24T04:18:06.088Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://jakearchibald.com/2021/serving-sharp-images-to-high-density-screens/">Halve the size of images by optimising for high density displays</a></p><p><strong>概要：</strong></p><p>本文探讨了高密度屏幕的普及程度以及如何为其优化图像。作者指出，80% 的用户使用 DPR（设备像素比）为 1.5 或更高的屏幕，因此在设计网站时需要考虑到这一点。对于高密度屏幕，需要将图像压缩至用户的设备像素而不是 CSS 像素，以确保图像清晰度。作者提供了一种简单的方法来处理图像，即将最大尺寸乘以 2 并使用较低质量进行编码，以便在高密度屏幕上始终显示清晰的图像。此外，作者还介绍了一种更加完整的方法，包括使用 <picture> 和 < source > 标签，在不同的屏幕分辨率下提供不同的图像，并提供了示例代码。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vite 5・vitejs/vite・讨论 #12466]]></title>
        <id>https://github.com/vitejs/vite/discussions/12466</id>
        <link href="https://github.com/vitejs/vite/discussions/12466"/>
        <updated>2023-03-24T00:02:52.735Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/vitejs/vite/discussions/12466">Vite 5 · vitejs/vite · Discussion #12466</a></p><p><strong>概要：</strong></p><p>Vite 开始讨论下一个主要版本的需求，以收集来自下游生态系统和用户的早期反馈。Vite 5 将在 2023 年 9 月 11 日发布，支持 Node 14 和 Node 16，不支持非活动 LTS 版本（Node 15、Node 17、Node 19）。Vite 5 的开发将重点关注性能方面的改进，并可能引入一些破坏性变化。同时，Vite 还在考虑将 vite-node 移动到 Vite 核心作为 SSR 的替代方案。开发者可以在 Vite 5 的里程碑中跟踪新问题和 PR。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to get a cool NPM package name? 

如何获得一个酷炫的 NPM 包名？]]></title>
        <id>https://unix.bio/posts/how-to-get-npm-package-name</id>
        <link href="https://unix.bio/posts/how-to-get-npm-package-name"/>
        <updated>2023-03-23T15:11:49.813Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://unix.bio/posts/how-to-get-npm-package-name">怎样获得一个很酷的 NPM 包名</a></p><p><strong>概要：</strong></p><p>本文介绍了如何通过 NPM 的争议政策来申请将占位包的所有权转移给自己。对于长期没有更新或仅仅是占位的包，NPM 工作人员会在 4 周后自动将包的 owner 设置为申请者的用户名。申请者需要发送邮件至包的所有者并抄送 support@npmjs.com，并说明申请转移的原因、包名以及自己的 npm username。值得注意的是，如果要转移的包存在商标版权侵犯或者是占位问题，NPM 工作人员将立刻处理。关于组织与用户名的转移，组织可以直接联系 support@npmjs.com，而用户名的转移则被认为是 “几乎不可能的”。如果发现包含违反当地法律、不合适的内容、侵权等问题，可以举报滥用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[您可能不需要的钩子]]></title>
        <id>https://reacttraining.com/blog/hooks-you-probably-dont-need</id>
        <link href="https://reacttraining.com/blog/hooks-you-probably-dont-need"/>
        <updated>2023-03-23T00:45:31.085Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://reacttraining.com/blog/hooks-you-probably-dont-need">Hooks You Probably Don't Need</a></p><p><strong>概要：</strong></p><p>本文介绍了 React Hooks 中一些不太常用的 Hook，包括 useDebugValue ()、useInsertionEffect ()、useImperativeHandle ()、useSyncExternalStore ()、useDeferredValue ()、useEffect () 和 useLayoutEffect ()。作者将这些 Hook 按照使用频率分为三类：不太可能使用的（红色）、偶尔会使用的（橙色）和根据具体情况而定的（绿色）。其中，useDebugValue () 用于在 DevTools 中为自定义 Hook 创建标签以进行调试；useInsertionEffect () 主要面向 CSS-in-JS 库开发者；useImperativeHandle () 用于限制或自定义向父组件暴露的 DOM 元素 API；useSyncExternalStore () 适用于第三方状态管理库或公开可变值和事件的浏览器 API；useDeferredValue () 用于显示过时内容并在加载新内容时延迟重新渲染 UI；useEffect () 用于处理渲染阶段的副作用，如数据获取；useLayoutEffect () 则用于在 UI 渲染前运行同步副作用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无限混音 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support</id>
        <link href="https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support"/>
        <updated>2023-03-23T00:39:59.131Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support">Remix without Limits – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel has announced an advanced integration with Remix, a server-rendered React framework. The integration allows developers to stream content dynamically using Node.js and Edge runtimes, build serverless APIs with Remix and a route loader, use powerful cache headers like stale-while-revalidate for advanced caching, and run data mutations inside Serverless or Edge Functions. The integration also supports both Node.js and Web/Edge-oriented runtimes on a per-route basis, enabling developers to take advantage of the best parts of both. Additionally, Vercel's Edge Network Cache supports caching loader responses and newer caching headers like stale-if-error.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实验室：我们正在进行的工作 ——2023 年 3 月 ——React]]></title>
        <id>https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023</id>
        <link href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023"/>
        <updated>2023-03-23T00:04:10.043Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023">React Labs: What We've Been Working On – March 2023 – React</a></p><p><strong>概要：</strong></p><p>React Labs 发布了最新的研究进展，包括 React Server Components、Asset Loading、Document Metadata、React Optimizing Compiler、Offscreen Rendering 和 Transition Tracing 等。其中，React Server Components 是由 React 团队设计的一种新的应用架构，它结合了服务器中心多页面应用程序的简单 “请求 / 响应” 模型和客户端中心单页面应用程序的无缝交互性，同时提供了一种新的组件类型 ——Server Components，它们可以在构建期间运行，也可以在服务器上运行，让您无需构建 API 即可访问数据层。另外，React Labs 还在开发 Suspense、Transition Tracing 等功能，以提高 React 的性能和用户体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[那么，您已经安装了 `fzf`。现在该怎么办？]]></title>
        <id>https://andrew-quinn.me/fzf/</id>
        <link href="https://andrew-quinn.me/fzf/"/>
        <updated>2023-03-22T15:41:43.724Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://andrew-quinn.me/fzf/">So you've installed `fzf`. Now what?</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 fzf 的工具，它是一个命令行模糊搜索工具，可以极大地提高 Linux 和 Windows 终端用户的效率。作者提到，fzf 的快捷键能够替代基础版本的 Ctrl+R，并且还有一些其他功能，例如 Alt+C 可以快速跳转目录，vi $(fzf) 可以模糊查找文件并打开编辑器等。此外，作者还介绍了另一个工具 rg，它是一个快速的递归 grep 工具，可以与 fzf 结合使用来进行模糊搜索文件内容。总之，fzf 和 rg 都是非常实用的命令行工具，值得一试。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Copilot X：AI 动力的开发者体验 | GitHub 博客]]></title>
        <id>https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/</id>
        <link href="https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/"/>
        <updated>2023-03-22T14:38:23.977Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/">GitHub Copilot X: The AI-powered developer experience | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub Copilot X 是 GitHub 的新一代 AI 辅助开发工具，它将 AI 引入整个开发生命周期中。除了自动完成注释和代码外，Copilot X 还支持聊天和语音交互，并在 pull requests、命令行和文档中提供 AI 支持。Copilot X 基于 OpenAI 的 GPT-4 模型，可以为开发人员生成单元测试、修复错误等。此外，Copilot X 还支持针对文档的 ChatGPT 接口，让开发人员能够快速获取关于 React、Azure Docs 和 MDN 等文档的答案。GitHub 希望通过 Copilot X 改变开发者的工作方式，提高其生产力和创造力。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 2023 年开始一个 React 项目]]></title>
        <id>https://www.robinwieruch.de/react-starter/</id>
        <link href="https://www.robinwieruch.de/react-starter/"/>
        <updated>2023-03-22T04:52:06.786Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.robinwieruch.de/react-starter/">How to start a React Project in 2023</a></p><p><strong>概要：</strong></p><p>本文介绍了几种新 React 项目的起始套件，包括 React with Vite、React with Next、React with Astro 等。作者对每种套件的优缺点、开发者所需技能水平以及针对 React 开发者提供的特性进行了分析，并给出了不同需求的三种解决方案。最后，文章总结了一些关于 React 起始项目的思考和建议。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务器首选框架 - HackMD]]></title>
        <id>https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di</id>
        <link href="https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di"/>
        <updated>2023-03-22T04:34:33.396Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di">Server First Framework - HackMD</a></p><p><strong>概要：</strong></p><p>该文章提出了一个名为 “Server First Framework” 的框架概念，预计将于 2023 年推出。作者认为，虽然过去十年的单页面应用程序（SPA）教会了我们很多东西，但我们现在携带了太多负担。设计面向服务器的框架时，要避免使用过多的同构倾向。

该框架的初始页面呈现与 Islands 框架非常相似。所有组件都是经过服务器渲染并发送到浏览器的。客户端组件道具被序列化，并启动任何资源内部的客户端组件。客户端组件被收集并且被水合（如果流式传输可用）。对于后续的导航，路由器将使用下一个 URL（包括当前 URL）请求服务器。服务器能够处理它以确定需要呈现哪些路由部分。同时，客户端请求下一个 URL 所需的所有 Islands 以加载代码。服务器仅呈现新路由部分，跳过呈现客户端组件，但仍然序列化道具。客户端接收响应，并能够使用 HTML 差异交换路由输出。在核心部分，变异遵循 MPA 的模式。您发送数据，服务器响应表示该更改的新标记。您可以将其视为表单提交。该请求响应下一页，因此处理程序可能会使用重定向 / 无效返回语法，即使它们都作为同一服务器响应的一部分进行处理。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编写你自己的响应式信号库]]></title>
        <id>https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/</id>
        <link href="https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/"/>
        <updated>2023-03-21T04:35:53.580Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/">Writing Your Own Reactive Signal Library</a></p><p><strong>概要：</strong></p><p>近来，前端领域出现了对细粒度反应性的新发现，这是一种通过使用三个主要原语：信号、效果和备忘录来构建反应式用户界面的风格。最近，我们看到像 Angular、Preact 和 Qwik 这样的框架在其现有框架中添加了信号。当然，SolidJS 是我选择的框架，创建者 Ryan Carniato 也引领了前端框架中信号的流行趋势。

什么是信号？

“信号” 这个名字并不特别描述性，所以它可能会让人感到有点困惑，不知道它提供了什么好处，以及它与 RxJS Observables 之类的东西有何不同。SolidJS 提供了一个很好的定义：

信号是事件发射器，它们保存订阅列表。每当它们的值发生变化时，它们就会通知其订阅者。

- SolidJS 文档

如果这不完全有意义，不用担心 —— 我们将通过编写自己的信号来学习！

为什么要创建自己的信号？

如果所有这些库都已经提供了信号原语，为什么我们要编写自己的信号呢？实际上，主要是作为一种学习体验！我不一定建议使用我们编写的内容来代替 Solid 等框架，因为它包含了针对不同边缘情况的更高级优化。相反，这种做法将帮助您更好地理解 Solid 和反应性的工作方式。

基础知识

对于我们的基本反应系统，我们将创建两个原语：createSignal 和 createEffect。备忘录（又称 createMemo）是反应性的第</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SPA 视图过渡在 Chrome 111 中实现 - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/blog/spa-view-transitions-land/</id>
        <link href="https://developer.chrome.com/blog/spa-view-transitions-land/"/>
        <updated>2023-03-21T04:35:25.858Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/spa-view-transitions-land/">SPA view transitions land in Chrome 111 - Chrome Developers</a></p><p><strong>概要：</strong></p><p>View Transition API 是一种可以在单个步骤中更新 DOM 的 API，同时生成两种状态之间的动画过渡。该功能目前只在 Chrome 浏览器上可用，但可以作为逐步增强使用。View Transitions API 设计成可以跨同源文档工作，下一步将优化它的性能和扩展性。该 API 还支持多种扩展，包括文档之间的转换、组合器驱动的动画、范围转换、嵌套转换组、转换类别等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Dagster、dbt 和 BigQuery 追踪假的 GitHub Star 黑市 | Dagster 博客]]></title>
        <id>https://dagster.io/blog/fake-stars</id>
        <link href="https://dagster.io/blog/fake-stars"/>
        <updated>2023-03-21T04:34:12.852Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dagster.io/blog/fake-stars">Tracking the Fake GitHub Star Black Market with Dagster, dbt and BigQuery | Dagster Blog</a></p><p><strong>概要：</strong></p><p>GitHub stars 是 GitHub 上社交证明的主要指标之一。然而，虚假的 stars 也会影响高风险决策，如企业使用哪些项目、哪些创业公司获得资金以及哪些公司有才华的专业人士加入。Dagster 团队发现了一些新的开源项目突然在几天内获得数百个星星，这让他们产生了怀疑。因此，他们购买了一些虚假的 stars，并通过 GitHub REST API 和 GitHub Archive 数据库运行了一些 repos 测试。他们采用了两种方法来识别虚假 stars：识别明显的伪造和识别复杂的伪造。最终，他们发现了一个简单的 “低活跃度” 启发式，可以检测到许多（但不是全部）涉嫌伪造的账户。另外，他们使用了无监督聚类技术来识别更复杂的虚假账户。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端开发的终结]]></title>
        <id>https://www.joshwcomeau.com/blog/the-end-of-frontend-development/</id>
        <link href="https://www.joshwcomeau.com/blog/the-end-of-frontend-development/"/>
        <updated>2023-03-21T04:25:39.556Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshwcomeau.com/blog/the-end-of-frontend-development/">The End of Front-End Development</a></p><p><strong>概要：</strong></p><p>很多初入行的开发者越来越担心人工智能的崛起，他们看到了像 GPT-4 这样的工具越来越令人印象深刻的演示，担心等到他们精通 HTML/CSS/JS 时，就没有任何工作机会了。然而，作者并不认为 Web 开发人员的工作将会消失。虽然 AI 会改变一些事情，但并不是人们所说的那种可怕的方式。作者认为最有可能的情况是，像 GPT-4 这样的工具将被整合到开发工具中，用于增强熟练开发人员的能力。而且，如果每个开发人员都变得更有效率，那么需求肯定会超过供应，因此总的开发人员数量可能会增加。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你需要知道平衡！CSS 平衡！| pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/you-need-to-know-the-balance-css-balance/</id>
        <link href="https://pawelgrzybek.com/you-need-to-know-the-balance-css-balance/"/>
        <updated>2023-03-20T13:06:23.086Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/you-need-to-know-the-balance-css-balance/">You need to know the balance! CSS balance! | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>本文介绍了 CSS Text Module Level 4 的一项新功能 ——text-wrap: balance。该功能可以在多行文本中更好地分配剩余空间，避免出现排版上的问题。然而，由于其算法需要大量资源，目前仅限于文本长度较短的情况下使用。规范草案将此限制设置为 10 行，但当前的 Google Chrome Canary 实现将此功能限制为 4 行。未来，可能不再需要 React Wrap Balancer 等工具。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么我们将 package.json 支持添加到 Deno 中]]></title>
        <id>https://deno.com/blog/package-json-support</id>
        <link href="https://deno.com/blog/package-json-support"/>
        <updated>2023-03-20T04:08:58.299Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/package-json-support">Why We Added package.json Support to Deno</a></p><p><strong>概要：</strong></p><p>Deno 最新版本的发布引入了一个重大变化：通过支持 package.json，提供了增强的 Node 和 NPM 兼容性。这一更新引发了关于我们的优先级是否发生了变化的问题，因为 Deno 长期以来一直被视为与 Node 不同的道路开拓者。事实上，在第一个 Deno 演示中，明确提到了 package.json 是一个遗憾。因此，许多用户对此发展感到惊讶。本文将解决这些问题，分享我们不断发展的思想，并概述我们的未来目标。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 useImperativeHandle 进行细调 refs]]></title>
        <id>https://prateeksurana.me/blog/fine-tuning-refs-with-useimperativehandle/</id>
        <link href="https://prateeksurana.me/blog/fine-tuning-refs-with-useimperativehandle/"/>
        <updated>2023-03-20T04:07:57.935Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://prateeksurana.me/blog/fine-tuning-refs-with-useimperativehandle/">Fine-tuning refs with useImperativeHandle</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中使用 refs 和 useImperativeHandle 的方法。Refs 是一种用于在组件之间传递数据的机制，可以让你访问 DOM 节点并使用原生 JavaScript DOM API 对其进行操作。useImperativeHandle 允许你自定义要公开的 ref 处理程序，以便只公开子组件的特定方法。然而，需要注意的是，在 React 中，最好不要使用 refs 来实现可以通过 props 实现的命令式行为，因为这违反了 React 的核心原则。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重复自己，做更多的事情，重新书写一切。]]></title>
        <id>https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and</id>
        <link href="https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and"/>
        <updated>2023-03-19T14:25:34.198Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and">Repeat yourself, do more than one thing, and rewrite everything</a></p><p><strong>概要：</strong></p><p>编程中的常见建议 “不要重复自己”（DRY）可能会导致更多问题，而不是解决问题。过于严格地遵循这个原则可能会导致程序员创建一个具有四个布尔标志和一系列行为矩阵的函数，并在更改代码时需要小心地进行导航。将事物分成简单的单元可能会导致笨拙的组合和协调交叉变化的困难。避免重写意味着它们通常被推迟到没有成功的机会。但是，有时候遵循这个建议的最佳方法是做相反的事情：采用特性开关并不断重写代码，将事物汇集在一起以便更容易管理它们之间的协调，并重复自己以避免在一个函数中实现所有内容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不要使用过时的机器人]]></title>
        <id>https://fvsch.com/stale-bots</id>
        <link href="https://fvsch.com/stale-bots"/>
        <updated>2023-03-19T14:24:50.555Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fvsch.com/stale-bots">Don’t use stale bots</a></p><p><strong>概要：</strong></p><p>本文讨论了软件项目中的 “过时机器人” 问题。过时机器人是指在一段时间内没有活动的情况下，自动将问题标记为 “已关闭” 的自动化流程。使用过时机器人会导致用户体验变差，因为它们可能会关闭具有很好复现步骤、截图和评论的问题，这会让用户觉得他们的努力不被重视。此外，过时机器人也会导致重复问题增加，因为关闭的问题不会出现在搜索结果中。文章建议替代过时机器人的方法包括：接受大量开放问题、设置问题筛选流程、制定项目管理计划等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本地 CSS 嵌套已经到达 | pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/native-css-nesting-landed/</id>
        <link href="https://pawelgrzybek.com/native-css-nesting-landed/"/>
        <updated>2023-03-19T13:45:47.967Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/native-css-nesting-landed/">Native CSS nesting landed | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>本文介绍了原生 CSS 嵌套的语法和用法，并与 Sass 的嵌套规则进行了比较。作者表示，原生 CSS 嵌套的语法应该对于熟悉 Sass 的人来说很容易理解。此外，文章还提到，CSS 嵌套是 CSS Nesting 规范的第一个版本，随着规范的演进，其功能和语法可能会发生变化。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - xenova/transformers.js：在您的浏览器中运行🤗变形金刚！]]></title>
        <id>https://github.com/xenova/transformers.js</id>
        <link href="https://github.com/xenova/transformers.js"/>
        <updated>2023-03-19T09:17:05.588Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/xenova/transformers.js">GitHub - xenova/transformers.js: Run 🤗 Transformers in your browser!</a></p><p><strong>概要：</strong></p><p>Transformers.js 是一个可以在浏览器中运行的🤗 Transformers 库，支持 BERT、ALBERT、DistilBERT、T5、T5v1.1、FLAN-T5、GPT2、BART、CodeGen、Whisper、CLIP、Vision Transformer 和 VisionEncoderDecoder 等模型，可用于各种任务，包括遮蔽语言建模、文本分类、文本到文本生成、翻译、摘要、问答、文本生成、自动语音识别、图像分类、零样本图像分类和图像到文本。用户可以通过 https://xenova.github.io/transformers.js/ 体验 demo。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 react.dev]]></title>
        <id>https://react.dev/blog/2023/03/16/introducing-react-dev</id>
        <link href="https://react.dev/blog/2023/03/16/introducing-react-dev"/>
        <updated>2023-03-19T08:44:54.669Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://react.dev/blog/2023/03/16/introducing-react-dev">Introducing react.dev</a></p><p><strong>概要：</strong></p><p>React 官方文档网站已经更新，现在的网址是 react.dev。新网站教授使用函数组件和 Hooks 的现代 React，并包括了图表、插图、挑战和 600 多个交互式示例。旧版 React 文档网站已移至 legacy.reactjs.org。新网站分为 “学习 React” 和 “API 参考” 两个主要部分，前者是一个自定进度的课程，后者提供每个 React API 的详细信息和用法示例。新网站还添加了很多沙盒，让用户可以快速玩转 React API、探索想法并检查理解。</p>]]></content>
    </entry>
</feed>
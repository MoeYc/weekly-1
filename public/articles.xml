<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-03-08T00:39:41.135Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[为什么 Turborepo 从 Go 迁移到 Rust - Vercel]]></title>
        <id>https://vercel.com/blog/turborepo-migration-go-rust</id>
        <link href="https://vercel.com/blog/turborepo-migration-go-rust"/>
        <updated>2023-03-08T00:38:52.418Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/turborepo-migration-go-rust">Why Turborepo is migrating from Go to Rust – Vercel</a></p><p><strong>概要：</strong></p><p>Turborepo 是一个用于 JavaScript 和 TypeScript 代码库的高性能构建系统。该系统通过增量构建、并行执行和远程缓存来避免重复工作。随着使用量的增加和产品需求的变化，Turborepo 决定从 Go 逐步迁移到 Rust。该迁移主要基于 Rust 的正确性、强大的生态系统以及开发人员的愉悦度等因素。Turborepo 正在采取渐进式的迁移方式，目前已经实现了 “Rust-Go-Rust Sandwich” 的状态，即 Rust 是入口点，可以选择使用 Rust 或 Go 来实现特定命令的功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[框架定义的基础设施 - Vercel]]></title>
        <id>https://vercel.com/blog/framework-defined-infrastructure</id>
        <link href="https://vercel.com/blog/framework-defined-infrastructure"/>
        <updated>2023-03-08T00:38:30.242Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/framework-defined-infrastructure">Framework-defined infrastructure – Vercel</a></p><p><strong>概要：</strong></p><p>框架定义的基础设施（FdI）是基础设施即代码（IaC）的演变，它自动提供源自框架和写在其中的应用程序的基础设施。FdI使用构建时的程序来解析写给框架的源代码，理解代码背后的意图，然后生成运行软件所需的IaC配置。这就通过真正的无服务器架构实现了更可预测、成本更低、风险更小的DevOps。FdI对服务器、消息队列和无服务器功能等云基元进行了抽象，使其成为框架概念的单纯实现细节。它提供了不同目标基础设施供应商之间的可移植性，消除了在生产中运行应用程序的基础设施的手动配置需求，并对预先审查的安全服务进行了标准化。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apple: M2 Eaten Dust for Security | Programmer's Cat]]></title>
        <id>https://catcoding.me/p/apple-perf/</id>
        <link href="https://catcoding.me/p/apple-perf/"/>
        <updated>2023-03-07T06:58:22.093Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://catcoding.me/p/apple-perf/">苹果：为了安全让 M2 吃灰 | 程序员的喵</a></p><p><strong>概要：</strong></p><p>该文章介绍了作者在使用苹果 M2 Pro 电脑时发现的一个让人大跌眼镜的设计：系统在运行任何软件之前都会进行校验和检查，以确保其不是恶意软件。这个过程需要通过网络请求与苹果服务器通信，导致性能下降。作者在编译 Rust 编译器项目时发现，相同测试用例的 Linux 虚拟机只需要 1.5 分钟，而 M2 Pro 需要 16 分钟。经过调查，作者发现关闭 System Integrity Protection（SIP）可以显著提高性能，但苹果回应称这是 “设计使然”。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如果我明天去世了，我的网络应用程序会持续多久？]]></title>
        <id>https://casparwre.de/blog/webapp-afterlife/</id>
        <link href="https://casparwre.de/blog/webapp-afterlife/"/>
        <updated>2023-03-07T04:19:32.094Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://casparwre.de/blog/webapp-afterlife/">If I died tomorrow, how long would my webapp keep running?</a></p><p><strong>概要：</strong></p><p>一位名为 “Hacker News” 的开发人员在其博客上分享了一个问题：如果他突然去世，他的 Web 应用程序会运行多久？他估计，只要数据库、域和云服务继续运作，该应用程序将无限期在线。但是，他也考虑到了可能导致应用程序离线的几种情况，例如自然灾害、基础设施故障、技术故障、产品故障、安全漏洞或恶意攻击以及付款故障。最后，他认为最有可能导致应用程序离线的是付款故障。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[沙虫审计]]></title>
        <id>https://docs.sandworm.dev/</id>
        <link href="https://docs.sandworm.dev/"/>
        <updated>2023-03-07T04:18:38.995Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://docs.sandworm.dev/">Sandworm Audit</a></p><p><strong>概要：</strong></p><p>Sandworm 是一个免费的开源命令行工具，可帮助 JavaScript 开发人员扫描项目和依赖项中的漏洞、许可证和其他问题。它支持自定义许可证策略，并提供 JSON 问题和许可证使用报告以及易于理解的 SVG 依赖树和树状图形可视化。此外，它还可以覆盖安全漏洞和包许可证信息，并生成所有依赖项和许可证信息的 CSV 文件。用户可以在终端中运行 Sandworm Audit 作为命令行工具，或者使用.sandworm.config.json 配置文件进行配置。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何为你完全不了解的项目做出贡献？]]></title>
        <id>https://grifel.dev/how-to-contribute-without-knowledge</id>
        <link href="https://grifel.dev/how-to-contribute-without-knowledge"/>
        <updated>2023-03-07T04:16:38.129Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://grifel.dev/how-to-contribute-without-knowledge">How to contribute to a project you have no idea about</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 Bun 的 JavaScript/TypeScript 运行时，它与 Deno/Node 类似，但具有更快的启动时间。作者通过编写测试套件来测试 Bun 的性能，并在测试过程中遇到了问题。作者分享了自己处理问题的方法，包括询问前任维护者、规范功能 / 问题、运行测试、编写测试用例并更改代码等步骤。最后，作者强调了测试套件的重要性，特别是在开源项目中，因为测试套件可以降低进入门槛，使得更多人可以参与项目。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比 Vite 快 5 倍？2ms HMR？Farm：基于 Rust 的极速构建引擎！]]></title>
        <id>https://zhuanlan.zhihu.com/p/611603260</id>
        <link href="https://zhuanlan.zhihu.com/p/611603260"/>
        <updated>2023-03-07T00:53:35.167Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/611603260">比 Vite 快 5 倍? 2ms HMR？Farm：基于 Rust 的极速构建引擎！</a></p><p><strong>概要：</strong></p><p>Farm 是一个使用 Rust 编写的构建引擎，比 Webpack 快 10 倍以上，比 Vite 快 5 倍。它支持 Html、Css、Js、Jsx、Ts、Tsx、静态资源等模块的编译能力，并且采用按需编译，在加载时编译除首屏需要的模块外的其他模块，理论上对任意规模的项目都能支持秒启动。所有能力都由插件实现，支持 Rust 和 Js 插件。Farm 在开发环境和生产环境下的编译行为保持一致，同时自动根据依赖关系、资源大小等因素将项目拆分成小 bundle，解决了 bundle 模式的缓存命中问题以及 unbundle 模式的请求数量问题。目前 Farm 已经更新到 0.3 版本，但生产环境优化还在开发中，所以请谨慎使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 初学者常见错误]]></title>
        <id>https://www.joshwcomeau.com/react/common-beginner-mistakes/</id>
        <link href="https://www.joshwcomeau.com/react/common-beginner-mistakes/"/>
        <updated>2023-03-07T00:46:48.674Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshwcomeau.com/react/common-beginner-mistakes/">Common Beginner Mistakes with React</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 React 开发中常见的 9 种陷阱，包括：使用零进行条件判断、直接修改状态、未生成 key、缺少空格、在更改状态后访问它、返回多个元素、从不受控制到受控制的转换、缺少样式括号和异步效果函数。对于每种陷阱，文章都提供了解决方法，并给出了示例代码。此外，作者还介绍了他正在开发的在线课程 The Joy of React，旨在帮助人们建立自己的 React 直觉。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[@githubnext/github-copilot-cli

请注意，这是一个英文文本，无法直接翻译为中文。如果您需要更多帮助，请提供更多上下文或详细信息。]]></title>
        <id>https://www.npmjs.com/package/@githubnext/github-copilot-cli#whats-the-point-of-the-eval-and-alias-stuff</id>
        <link href="https://www.npmjs.com/package/@githubnext/github-copilot-cli#whats-the-point-of-the-eval-and-alias-stuff"/>
        <updated>2023-03-07T00:46:09.662Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.npmjs.com/package/@githubnext/github-copilot-cli#whats-the-point-of-the-eval-and-alias-stuff">@githubnext/github-copilot-cli</a></p><p><strong>概要：</strong></p><p>GitHub Copilot CLI 是一个命令行体验，可以让 GitHub Copilot 在命令行中帮助你。它将自然语言转换为 shell 命令，并具有不同领域的模式。安装后，您可以使用以下三个命令：??：将自然语言翻译为任意 shell 命令；git?：将自然语言翻译为 Git 命令；gh?：将自然语言翻译为 GitHub CLI 命令。GitHub Copilot CLI 还会尝试逐步分解并解释建议的命令将做什么。要使用 GitHub Copilot CLI，您必须拥有对 GitHub Copilot 的访问权限。支持的平台包括 Linux 上的 zsh 等，但可能会向您建议在您的平台或终端上无法运行的命令。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 tRPC 和 React 的全栈 TypeScript]]></title>
        <id>https://www.robinwieruch.de/react-trpc/</id>
        <link href="https://www.robinwieruch.de/react-trpc/"/>
        <updated>2023-03-06T14:43:59.460Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.robinwieruch.de/react-trpc/">Full-Stack TypeScript with tRPC and React</a></p><p><strong>概要：</strong></p><p>tRPC 是一种使用 TypeScript 在全栈应用程序中创建完全类型安全 API 的方法。 tRPC 服务器应用程序生成具有类型安全函数的类型安全路由器（例如 CRUD 操作：创建用户，按标识符获取用户，获取所有用户），客户端应用程序可以直接调用这些函数。 在幕后，仍然使用 HTTP 在客户端和服务器之间通信。相比 GraphQL 和 REST，tRPC 主要用于较小的项目，其中不需要协调许多服务（例如 GraphQL），或者我们不一定按照标准化的 RESTful 方法工作。但是，随时可以从 tRPC 迁移到 GraphQL / REST，因为 tRPC 最终只是服务器上的函数，可以直接在 REST 路由器或 GraphQL 解析器中使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Oxy 是 Cloudflare 基于 Rust 的下一代代理框架。]]></title>
        <id>https://blog.cloudflare.com/introducing-oxy/</id>
        <link href="https://blog.cloudflare.com/introducing-oxy/"/>
        <updated>2023-03-06T06:19:45.974Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.cloudflare.com/introducing-oxy/">Oxy is Cloudflare's Rust-based next generation proxy framework</a></p><p><strong>概要：</strong></p><p>Oxy 是一款使用 Rust 编程语言开发的现代代理框架，是 Cloudflare 项目的基础之一，包括 Zero Trust Gateway、iCloud Private Relay 第二跳代理和内部出口路由服务。Oxy 利用了 Cloudflare 多年构建高负载代理的经验，实现了最新的通信协议，可以轻松构建可容纳大量每日流量的复杂服务。Oxy 支持多种通信协议，包括 HTTP 1/2/3、TCP 和 UDP 流量等，可以在 OSI 模型的多个层次上分析和操作流量。同时，它还支持 TLS 加密和安全认证，并提供全面的监控和分析功能。Oxy 的设计符合 Cloudflare 的迭代式开发方法，可以根据应用程序要求进行定制，允许工程师调整每个组件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我喜欢用 Rust 来创业。但我不会再选择它了。]]></title>
        <id>https://www.propelauth.com/post/i-love-building-a-startup-in-rust-i-wouldnt-pick-it-again</id>
        <link href="https://www.propelauth.com/post/i-love-building-a-startup-in-rust-i-wouldnt-pick-it-again"/>
        <updated>2023-03-06T04:46:28.915Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.propelauth.com/post/i-love-building-a-startup-in-rust-i-wouldnt-pick-it-again">I love building a startup in Rust. I wouldn't pick it again.</a></p><p><strong>概要：</strong></p><p>该文章介绍了一家初创公司在选择编程语言时的经验教训。作者表示，尽管他非常喜欢 Rust 语言，但如果重新开始，他不会再次选择它。作者解释了他们最初选择 Rust 的原因，包括安全性和代码可读性等方面。然而，作者认为，在初创阶段，快速迭代比构建高效的代码更为重要。此外，对于不熟悉 Rust 的新员工来说，学习曲线也较陡峭。作者建议，在确定产品方向并需要构建高性能系统时，再考虑使用 Rust 语言。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优秀工程师和卓越工程师的区别]]></title>
        <id>https://www.intercom.com/blog/traits-of-exceptional-engineers/</id>
        <link href="https://www.intercom.com/blog/traits-of-exceptional-engineers/"/>
        <updated>2023-03-06T04:44:50.950Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.intercom.com/blog/traits-of-exceptional-engineers/">The difference between good and great engineers</a></p><p><strong>概要：</strong></p><p>Intercom's former Senior Director of Demand Generation, Brian Kotlyar, has outlined six traits that make exceptional engineers. These include ambition and determination, habitual simplification, the ability to debug anything quickly, a willingness to help others be great, knowing what is valuable, and being creative and positive. Kotlyar said engineering culture is shaped by the people hired, the actions they take, and the traits that are rewarded and celebrated.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[36 种不同的生活方式]]></title>
        <id>https://chrisguillebeau.com/36-ways</id>
        <link href="https://chrisguillebeau.com/36-ways"/>
        <updated>2023-03-06T04:43:13.118Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://chrisguillebeau.com/36-ways">36 Ways to Live Differently</a></p><p><strong>概要：</strong></p><p>这篇文章提供了一些方法，可以让你生活得更好。通过不断接触新的思想和实践，你可以学会不同的思考方式和生活方式。文章列举了一系列方法，包括认识到生活中的隐含规则、学会记笔记、思考与自己观点相反的政治党派或宗教信仰等等。此外，文章还提醒读者要注意身体感受，避免比较、远离负面人物、保持乐观等等。最后，作者强调了三个重要的方面：学习、行动和善良。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 React-Spring 创建动画：全面指南]]></title>
        <id>https://voskan.host/2023/02/08/creating-animations-in-react-with-react-spring/</id>
        <link href="https://voskan.host/2023/02/08/creating-animations-in-react-with-react-spring/"/>
        <updated>2023-03-06T04:40:36.350Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://voskan.host/2023/02/08/creating-animations-in-react-with-react-spring/">Creating Animations in React with React-Spring: A Comprehensive Guide</a></p><p><strong>概要：</strong></p><p>本文介绍了如何在 React 中实现动画效果。作者介绍了 React-Spring 这个流行的 JavaScript 库，它提供了一组强大的钩子，可以用于向组件添加动画效果。文章详细介绍了如何安装和使用 React-Spring，并提供了许多示例代码来展示如何创建简单的淡入淡出和滑动动画，以及更复杂的动画效果，如关键帧和动画序列。最后，作者总结了使用 React-Spring 的好处，包括简化的 API、React Native 支持、良好的性能和互动性等，并推荐开发人员通过探索 React-Spring 文档并尝试本文介绍的示例来学习如何使用该库创建动画效果。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[停止使用 “技术债务” 的说法。]]></title>
        <id>https://stackoverflow.blog/2023/02/27/stop-saying-technical-debt/</id>
        <link href="https://stackoverflow.blog/2023/02/27/stop-saying-technical-debt/"/>
        <updated>2023-03-05T12:53:44.743Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://stackoverflow.blog/2023/02/27/stop-saying-technical-debt/">Stop saying “technical debt”</a></p><p><strong>概要：</strong></p><p>开发团队常常陷入技术债务的泥潭，每次发布新功能都会遇到各种问题。但是，这种情况往往是我们自己给自己挖的坑。我们试图通过使用 “技术债务” 这个词来让商业人士、设计师、产品经理和工程师达成共识，但这个词在不同人看来意义不同，导致沟通困难。如果我们将技术债务等同于糟糕的代码，就会误以为前任开发人员干得不好，而实际上可能是有某些限制。我们应该选择一些可衡量的指标来评估系统的质量，如维护负荷。我们可以跟非工程团队的人谈论这个数字，让他们帮助我们减少维护负荷。为了最小化维护负荷的增长，我们需要进行良好的代码管理，包括记录系统、从代码中恢复上下文和为未来的更改进行设计。如果我们能够在保持日常代码管理例程的同时，跟踪维护任务的来源并解决这些问题，那么我们就可以实现负载增长为负数，即代码随时间变得更易于维护。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Node.js 中激活检查员的三种方法 | pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/three-ways-to-activate-an-inspector-in-node-js/</id>
        <link href="https://pawelgrzybek.com/three-ways-to-activate-an-inspector-in-node-js/"/>
        <updated>2023-03-04T01:07:48.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/three-ways-to-activate-an-inspector-in-node-js/">Three ways to activate an inspector in Node.js | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>本文介绍了三种激活 Node.js inspector 的方法，其中一种是使用 NODE_OPTIONS 环境变量来调试间接运行 Node 的进程。如果您是 Node.js 调试器的新手，可以查看作者之前发布的两篇文章：“在 Google Chrome 中进行基本的 Node.js 调试” 和 “解释 Visual Studio Code 调试器中的继续、步过、步入和步出操作”。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你不需要构建步骤]]></title>
        <id>https://deno.com/blog/you-dont-need-a-build-step</id>
        <link href="https://deno.com/blog/you-dont-need-a-build-step"/>
        <updated>2023-03-03T04:36:45.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/you-dont-need-a-build-step">You Don't Need a Build Step</a></p><p><strong>概要：</strong></p><p>本文探讨了为什么现代 Web 开发需要构建步骤，以及如何使用 Deno 和 Fresh 等工具实现无需构建的开发。文章介绍了构建步骤的来龙去脉，包括编译、压缩、打包和代码分割等过程，并列举了一些流行的构建工具。作者认为，构建步骤是现代 Web 开发不可避免的一部分，但也带来了复杂性和长时间的构建时间。使用 Deno 和 Fresh 可以实现无需构建的开发，从而提高开发效率和代码质量。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决技术债务的 25% 规则]]></title>
        <id>https://shopify.engineering/technical-debt-25-percent-rule</id>
        <link href="https://shopify.engineering/technical-debt-25-percent-rule"/>
        <updated>2023-03-03T04:35:51.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://shopify.engineering/technical-debt-25-percent-rule">The 25 Percent Rule for Tackling Technical Debt</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了技术债务的不同类型，并提出了一种 “25% 规则”，即每周花费 10％的时间解决日常技术债务，另外 10％的时间解决每周技术债务，剩下的 5％用于处理每月和每年的技术债务。作者认为，解决技术债务并不是大规模修复的问题，而是通过文化建设来实现。通过改进日常工作中的代码、庆祝重构代码的能力以及知道何时选择好的而不是完美的，可以帮助解决技术债务问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Signia]]></title>
        <id>https://tldraw.substack.com/p/introducing-signia</id>
        <link href="https://tldraw.substack.com/p/introducing-signia"/>
        <updated>2023-03-03T04:34:49.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tldraw.substack.com/p/introducing-signia">Introducing Signia</a></p><p><strong>概要：</strong></p><p>数字协作白板 tldraw 的开发团队发布了其核心反应式状态管理系统的开源项目 Signia。该库是用于使用基于逻辑时钟的新惰性反应模型处理细粒度反应值（称为 “信号”）的原始库，它诞生的原因是需要高效地处理经常更改的大型派生不可变集合。除了核心库之外，还发布了与 React 绑定的内容。Signia 的 API 类似于 Jotai、@preact/signals 和 Recoil 等类库，其主要区别特征是具有增量派生和内置支持回滚的事务。Signia 的反应性系统基于单个整数，即全局逻辑时钟，每当更新根状态值时，该时钟就会递增。比较时钟值允许 Signia 始终缓存派生值，而不管它们是否正在被积极观察。Signia 的响应式系统基于逻辑时钟和差异，可以实现增量计算派生值。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenAI 现在已经成为它所承诺不会成为的一切：企业、闭源和盈利。]]></title>
        <id>https://www.vice.com/en/article/5d3naz/openai-is-now-everything-it-promised-not-to-be-corporate-closed-source-and-for-profit</id>
        <link href="https://www.vice.com/en/article/5d3naz/openai-is-now-everything-it-promised-not-to-be-corporate-closed-source-and-for-profit"/>
        <updated>2023-03-03T04:20:33.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.vice.com/en/article/5d3naz/openai-is-now-everything-it-promised-not-to-be-corporate-closed-source-and-for-profit">OpenAI Is Now Everything It Promised Not to Be: Corporate, Closed-Source, and For-Profit</a></p><p><strong>概要：</strong></p><p>OpenAI, the AI research organization co-founded by Elon Musk and others, has shifted from its original non-profit mission to one of profit and secrecy, according to this Vice report. OpenAI was established in 2015 to advance digital intelligence for the benefit of humanity as a whole, unconstrained by financial return. However, the company has since become a for-profit entity, partnered with Microsoft and Bain, and is at the centre of an AI chatbot arms race. Critics argue that OpenAI is driven by speed and profit, rather than transparency and positive human impact, and that it is unleashing flawed technology that will increase workplace automation at the expense of human employees.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MRSK：随时随地部署 Web 应用程序]]></title>
        <id>https://mrsk.dev/</id>
        <link href="https://mrsk.dev/"/>
        <updated>2023-03-03T04:17:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://mrsk.dev/">MRSK: Deploy web apps anywhere</a></p><p><strong>概要：</strong></p><p>MRSK 是一个用于部署 Web 应用程序的工具，它使用 Docker 在裸机和云 VM 之间部署 Web 应用程序，而且没有停机时间。它使用动态反向代理 Traefik 来保持请求，同时启动新的应用程序容器并停止旧的容器。它可以无缝地跨多个主机使用 SSHKit 执行命令。虽然它最初是为 Rails 应用程序构建的，但它也适用于任何可以使用 Docker 进行容器化的 Web 应用程序。MRSK 旨在将商业平台提供的先进人体工程学方法带到部署 Web 应用程序的任何地方，从低成本的云选项到自己的裸金属。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过 SSH 远程访问您的 Repls]]></title>
        <id>https://blog.replit.com/ssh</id>
        <link href="https://blog.replit.com/ssh"/>
        <updated>2023-03-03T04:14:52.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.replit.com/ssh">Remote Access to Your Repls via SSH</a></p><p><strong>概要：</strong></p><p>Replit, a cloud-based coding platform, has added the ability to remotely access its Repls using SSH to all of its paid plans. Users subscribed to a paid plan can add their SSH keys and work with their Repl remotely. The move allows users to take full advantage of Replit's power while continuing to use their local development environment. Replit puts every Repl into its own container that runs once a connection is opened to it. Inside that container, an SSH server handles all remote access needs. A proxy receives the connection, verifies keys and routes the SSH connection through an encrypted SSH tunnel to the Repl.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ChatGPT 校对扩展程序适用于 Popclip。]]></title>
        <id>https://reorx.com/makers-daily/003-chatgpt-proofreader-extension-popclip/</id>
        <link href="https://reorx.com/makers-daily/003-chatgpt-proofreader-extension-popclip/"/>
        <updated>2023-03-03T01:27:12.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://reorx.com/makers-daily/003-chatgpt-proofreader-extension-popclip/">ChatGPT Proofreader extension for Popclip</a></p><p><strong>概要：</strong></p><p>OpenAI 发布了新的 ChatGPT API，解决了旧 API 存在的问题，并提供了更多的特性，如显式定义角色、选择性去掉会话中的信息、返回多个结果供选择等。一位开发者基于这个 API 做了一个名为 ChatGPT Proofreader 的扩展，提供了中英文润色功能。使用者只需在 Popclip 中选中文字并点击相应图标即可实现润色。此外，该开发者在 Twitter 上总结了 ChatGPT API 的优点，包括以上提到的特性以及使用 logit_bias 参数调整屏蔽特定词汇的功能，使用 temperature/top_p 参数调整结果相关性和准确性等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 LangChain.js 进行问答（Q&A）]]></title>
        <id>https://langchainers.hashnode.dev/question-answer-qa-using-langchainjs</id>
        <link href="https://langchainers.hashnode.dev/question-answer-qa-using-langchainjs"/>
        <updated>2023-03-03T00:28:53.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://langchainers.hashnode.dev/question-answer-qa-using-langchainjs">Question & Answer (Q&A) using LangChain.js</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 LangChain.js 库中的 Text Splitter、HNSWLib、OpenAIEmbeddings 和 Vector DBQA Chain 等工具进行问答系统的构建。其中，需要先安装 HNSWLib，并下载一份 State of the Union Speech 文件作为测试数据。通过复制代码并执行命令即可得到问答结果。总体来说，使用 LangChain.js 构建自定义问答系统非常简单。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[与行业合作推进 CHIPS - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/en/blog/working-with-the-industry-to-evolve-chips/</id>
        <link href="https://developer.chrome.com/en/blog/working-with-the-industry-to-evolve-chips/"/>
        <updated>2023-03-03T00:05:36.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/en/blog/working-with-the-industry-to-evolve-chips/">Working with the industry to evolve CHIPS - Chrome Developers</a></p><p><strong>概要：</strong></p><p>Cookies Having Independent Partitioned State (CHIPS) 是一种隐私沙箱技术，允许开发人员将 cookie 选择为 “分区” 存储，每个顶级站点有单独的 cookie 存储器。 CHIPS 的示例用例包括任何需要跨站子资源的会话或持久状态的情况，该状态仅限于用户在单个顶级站点上的活动，例如第三方聊天小部件、地图嵌入、子资源 CDN 负载平衡、无头 CMS 提供商等。 CHIPS 正在开发中，旨在成为开放网络标准。它正在隐私 CG 中进行讨论，并已经进行了 7 个月的起源试验，在此期间，Chrome 团队收到了有益的反馈。在开发过程中，团队与关键利益相关者合作，探索了这些反馈，从而得出了更新的设计，更好地服务于 Web 生态系统。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 信号的演变]]></title>
        <id>https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob</id>
        <link href="https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob"/>
        <updated>2023-03-03T00:01:10.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob">The Evolution of Signals in JavaScript</a></p><p><strong>概要：</strong></p><p>“Signals” 是一种前端技术，最早可以追溯到 20 世纪 60 年代的研究。它们在 JavaScript 中的应用可以追溯到最初的声明式 JavaScript 框架，并在多年间以不同的名称出现过。现在，它们似乎又回到了人们的视野中，出现在各种框架中。这篇文章介绍了 Signals 的历史和背景，并讨论了其未来的发展趋势。同时，作者还介绍了一些使用 Signals 的 JavaScript 框架，如 SolidJS、Vue、Preact 等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 与 Signals：10 年后]]></title>
        <id>https://dev.to/this-is-learning/react-vs-signals-10-years-later-3k71</id>
        <link href="https://dev.to/this-is-learning/react-vs-signals-10-years-later-3k71"/>
        <updated>2023-03-02T23:58:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/this-is-learning/react-vs-signals-10-years-later-3k71">React vs Signals: 10 Years Later</a></p><p><strong>概要：</strong></p><p>本文探讨了 JavaScript 中的信号（Signals）技术，以及它与 React 的区别和联系。信号是一种细粒度的响应式编程技术，可以用于前端开发中的数据流管理。尽管在 React 和虚拟 DOM 的兴起中，信号被认为是不可预测和危险的模式，但实际上信号从未消失，而是以第三方库或框架的形式存在。本文介绍了 SolidJS，这是一种新型的信号技术，它采用了组合、单向数据流和显式变异等原则，并将所有东西都视为 Effect，与 React 不同的是，它不会将所有操作视为纯函数，而是通过隔离更新来实现状态变化。作者认为，React 曾经 “修复” 了前端开发，但现在信号技术的复兴又将其推向了新的竞争时代。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我不确定我是否理解了这篇文章。我认为... — DEV 社区]]></title>
        <id>https://dev.to/dan_abramov/comment/256g9</id>
        <link href="https://dev.to/dan_abramov/comment/256g9"/>
        <updated>2023-03-02T23:57:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/dan_abramov/comment/256g9">I'm not sure I understood this article. I think... — DEV Community</a></p><p><strong>概要：</strong></p><p>本文探讨了 React 和 Solid 在处理渲染逻辑上的不同策略。React 的核心思想是，应该能够编写渲染逻辑，使其在初始化和更新时都能够运行，并且不会与传递的数据不同步。Solid 则只有模板中的 “空洞” 是响应式的，因此不能像 React 那样使用 if 语句和控制流。作者认为，Solid 的优点在于可以避免部分逻辑的重新执行，但这并不是最终的理想状态。通过编译器，可以实现在不重组代码的情况下自动确定 “组”，以达到类似 useMemo 的优化效果。最后，作者指出 React 不需要将渲染逻辑从内向外编写才能实现更新，这是 React 默认具备的响应性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Actions 导入器现已正式推出 | GitHub 博客]]></title>
        <id>https://github.blog/2023-03-01-github-actions-importer-is-now-generally-available/</id>
        <link href="https://github.blog/2023-03-01-github-actions-importer-is-now-generally-available/"/>
        <updated>2023-03-02T14:53:17.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-03-01-github-actions-importer-is-now-generally-available/">GitHub Actions Importer is now generally available | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub 推出了 GitHub Actions Importer，这是一款可帮助用户从 Azure DevOps、CircleCI、GitLab、Jenkins 和 Travis CI 迁移到 GitHub Actions 的工具。该产品是官方 GitHub CLI 的扩展，从今天开始任何 GitHub 用户都可以免费使用。GitHub Actions 提供强大的本地 CI/CD 功能，使得开发人员可以在 GitHub 上轻松启用和维护 CI/CD 工作流程，无需安装、集成和维护第三方工具。GitHub Actions Importer 采用分阶段方法简化迁移过程，包括计划、测试和迁移三个阶段。未来几个月，GitHub 将继续增强和更新 GitHub Actions Importer，以支持更多的 CI/CD 工具。</p>]]></content>
    </entry>
</feed>
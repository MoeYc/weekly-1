<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-05-04T02:06:56.974Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[介绍 Vercel 上的存储功能 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-storage</id>
        <link href="https://vercel.com/blog/vercel-storage"/>
        <updated>2023-05-04T01:58:00.921Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-storage">Introducing storage on Vercel – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel宣布了一套无服务器存储解决方案，包括Vercel KV，一个无服务器的Redis解决方案；Vercel Postgres，一个为前端建立的无服务器SQL数据库；以及Vercel Blob，一个在边缘上传和服务文件的解决方案。这些解决方案旨在使数据库成为Vercel前端云的一流部分，并使开发人员能够管理他们的前端存储需求，而不必担心基础设施。此举是由性能和个性化的需求所驱动的，因为框架变成了服务器优先和边缘优先，世界也从单体架构转向可组合的架构。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Deno KV。]]></title>
        <id>https://deno.com/blog/kv</id>
        <link href="https://deno.com/blog/kv"/>
        <updated>2023-05-04T01:56:27.393Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/kv">Announcing Deno KV</a></p><p><strong>概要：</strong></p><p>Deno KV 是一款全球复制、强一致性的键值数据库，可在 35 个地区实现低延迟读取。它可以无缝集成到开源 Deno 运行时中，无需任何配置即可在本地或作为托管服务运行。Deno KV 是一个简单但功能强大的一流原语，只暴露了少量方法来存储、检索、删除和枚举数据。它支持原子事务，提供外部一致性和线性化，并可通过 consistency："eventual" 选项放松一致性约束以提高读取操作的响应速度。Deno KV 适用于各种应用场景，如实时协作、用户数据管理和身份验证等。此外，它还提供了一些演示应用程序，如多人井字游戏、像素画板和共享任务列表等，以展示其能力。在未来几个月中，我们将推出更多功能，进一步简化构建和部署应用程序的过程。在 beta 期间，用户可以免费使用最多 1</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自主 GPT-4：从 ChatGPT 到 AutoGPT、AgentGPT、BabyAGI、HuggingGPT 等等。]]></title>
        <id>https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e</id>
        <link href="https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e"/>
        <updated>2023-05-03T10:36:11.064Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e">Autonomous GPT-4: From ChatGPT to AutoGPT, AgentGPT, BabyAGI, HuggingGPT, and Beyond</a></p><p><strong>概要：</strong></p><p>本文介绍了 ChatGPT 和 LLM 技术的兴起，这些先进的语言模型已经引起了开发者、爱好者和组织的广泛关注。为了更好地整合和构建这些先进模型，出现了像 LangChain 和 LlamaIndex 这样的平台。随着自动化任务和 AI 代理越来越多地利用 GPT-4 的能力，这些创新平台正在重新定义我们与 LLMs 互动的方式。本文还介绍了几个基于 GPT-4 的自主 AI 工具和应用，包括 Auto-GPT、AgentGPT、BabyAGI、HuggingGPT、Web LLM、God Mode 和 CAMEL。这些工具和应用可以分为命令行界面（CLI）和基于浏览器的解决方案两类。这些平台正在推动人工智能领域的突破性创新和进步。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 渲染交互指南]]></title>
        <id>https://ui.dev/why-react-renders</id>
        <link href="https://ui.dev/why-react-renders"/>
        <updated>2023-04-27T04:47:36.154Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://ui.dev/why-react-renders">The Interactive Guide to Rendering in React</a></p><p><strong>概要：</strong></p><p>本文主要介绍了 React 的渲染机制，即 React 只有在状态改变时才会重新渲染组件。当事件处理程序被调用时，如果其中包含 useState 的更新函数，并且新状态与快照中的状态不同，React 将触发重新渲染。此外，本文还介绍了 React 的批处理算法和 StrictMode 组件。最后，作者提醒读者，在实际开发中需要注意组件的纯度和性能问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用 Rust 和 Napi rs 在 NodeJs 中将 CSV 文件处理速度提高五倍]]></title>
        <id>https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs</id>
        <link href="https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs"/>
        <updated>2023-04-27T00:47:13.797Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs">How to process a CSV file five times faster in NodeJs with Rust and Napi rs</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Rust 和 Napi rs 在 NodeJs 中处理 CSV 文件。作者使用了 readline 模块来处理 CSV 文件，并记录了处理时间和吞吐量。然后作者使用了 Rust 编写了相同的代码，并通过 pv 命令进行了基准测试，发现 Rust 版本比 Nodejs 版本快五倍。最后，作者介绍了如何使用 Napi rs 将 Rust 代码编译成动态库，并在 Nodejs 中调用。总之，结合 Rust 和 Nodejs 可以实现更好的性能和效率。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 useReducer 的创造性方式]]></title>
        <id>https://www.code-insights.dev/posts/creative-ways-of-using-usereducer</id>
        <link href="https://www.code-insights.dev/posts/creative-ways-of-using-usereducer"/>
        <updated>2023-04-27T00:36:42.149Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.code-insights.dev/posts/creative-ways-of-using-usereducer">Creative ways of using useReducer</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 中的 useReducer 钩子函数，它可以用于管理复杂状态。通过传递一个 reducer 函数、一个初始值和一个可选的初始化函数，useReducer 返回一个包含当前状态和 dispatch 函数的数组。使用 dispatch 函数更新状态时，它会调用 reducer 函数并返回下一个状态。但是，由于函数式 JavaScript 的宽容性质，useReducer 还可以以不同的方式创造性地使用。文章提供了一些例子，如简单的开关、增量按钮、增强状态和安全状态等，演示了使用 useReducer 管理状态的优势。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年在哪里托管您的 Remix 应用程序？]]></title>
        <id>https://www.jacobparis.com/guides/where-to-host-remix</id>
        <link href="https://www.jacobparis.com/guides/where-to-host-remix"/>
        <updated>2023-04-27T00:36:17.402Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.jacobparis.com/guides/where-to-host-remix">Where to host your Remix app in 2023</a></p><p><strong>概要：</strong></p><p>本文介绍了多种应用托管方式，包括无服务器函数、Netlify、Vercel、Cloudflare Pages、Fastly、AWS Lambda 和长期运行的服务器。对于每种托管方式，文章列出了其优点和缺点，以及支持的功能和限制。需要根据自己的应用需求选择适合的托管方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现 experimental_useFormStatus by acdlite・Pull Request #26722・facebook/react]]></title>
        <id>https://github.com/facebook/react/pull/26722</id>
        <link href="https://github.com/facebook/react/pull/26722"/>
        <updated>2023-04-27T00:32:22.463Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/facebook/react/pull/26722">Implement experimental_useFormStatus by acdlite · Pull Request #26722 · facebook/react</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个新的 React Hook，可以读取其祖先表单组件的状态，用于实现加载指示器等功能。目前该 Hook 只在实验通道中可用，随着其稳定性的提高，将会发布更多 API 和文档。该 Hook 内部使用 startTransition 和上下文对象实现，但实际实现细节可能会发生变化。由于表单元素不能嵌套，因此实现者不需要跟踪多个嵌套的 “转换提供者”。虽然它使用通用的 Fiber 配置方法进行实现，但它目前仍基于 React DOM 的要求进行一些假设。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[岛屿的温和介绍]]></title>
        <id>https://deno.com/blog/intro-to-islands</id>
        <link href="https://deno.com/blog/intro-to-islands"/>
        <updated>2023-04-27T00:31:14.024Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/intro-to-islands">A Gentle Introduction to Islands</a></p><p><strong>概要：</strong></p><p>本文介绍了一种名为 “Islands” 的解决方案，用于应对那些需要一定交互性但不需要大量 JavaScript 的网站。Islands 是指使用 Preact 组件来实现交互，并在静态渲染的 HTML 页面中进行客户端渲染。这种方法避免了将整个框架打包发送到客户端的问题，同时也使开发人员能够更加有意识地选择何时使用 JavaScript。文章还提到了其他一些解决方案，如 React Server Components 和 Quik 的可恢复性，以及 Astro 和 Marko 等框架中类似的技术。总之，Islands 是一种简单而有效的解决方案，可以帮助开发人员更好地控制网站的交互性和 JavaScript 的使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我作为新经理所犯的一些错误]]></title>
        <id>https://www.benkuhn.net/newmgr/</id>
        <link href="https://www.benkuhn.net/newmgr/"/>
        <updated>2023-04-25T00:56:17.319Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.benkuhn.net/newmgr/">Some mistakes I made as a new manager</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了作者成为管理者的经历，以及他在这个过程中犯下的错误和解决策略。作者指出，作为一名管理者，最初的困难之一是难以确定自己的工作是否有用。他提供了三种应对策略：与上级领导沟通，寻求反馈，多元化生活体验。此外，作者还分享了其他的经验教训，如管理的重要性、任务相关成熟度、拖延维护、直接询问等。最后，作者总结了成为新管理者的困难所在，并鼓励读者不要害怕犯错，因为这是成长的必经之路。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 装饰器：完整指南]]></title>
        <id>https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/</id>
        <link href="https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/"/>
        <updated>2023-04-25T00:45:02.471Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/">TypeScript Decorators: A complete guide</a></p><p><strong>概要：</strong></p><p>本文介绍了 TypeScript 的装饰器，装饰器本质上是函数，可以用于给类、方法、属性等应用可重用的行为。不同类型的装饰器包括类装饰器、方法装饰器、属性装饰器、访问器装饰器和参数装饰器。装饰器可以用于实现各种功能，如前 / 后钩子、监视属性更改和方法调用、转换参数、自动序列化和反序列化、依赖注入等。使用装饰器的优点包括跨越关注点、依赖注入、验证和代码组织。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - partykit/partykit：有了朋友，一切都更好。]]></title>
        <id>https://github.com/partykit/partykit</id>
        <link href="https://github.com/partykit/partykit"/>
        <updated>2023-04-25T00:43:43.337Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/partykit/partykit">GitHub - partykit/partykit: Everything's better with friends.</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 partykit 的软件开发工具包，可以用于构建实时协作应用程序。用户可以将其与现有的 Web 应用程序一起使用，也可以从头开始构建新的应用程序。该工具包提供了简单易用的服务器和客户端代码，使用户能够轻松地添加实时协作功能，如协同编辑器、多人游戏等。此外，文章还介绍了 y-partykit 和 party.io 两个相关的库，可以帮助用户更方便地构建协作应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新的断点侧边栏如何帮助您更快地进行调试 - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/en/blog/breakpoint-ux-redesign/</id>
        <link href="https://developer.chrome.com/en/blog/breakpoint-ux-redesign/"/>
        <updated>2023-04-25T00:23:16.053Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/en/blog/breakpoint-ux-redesign/">How the new Breakpoints sidebar helps you debug faster - Chrome Developers</a></p><p><strong>概要：</strong></p><p>Google Chrome 最新版本的调试工具已经更新了断点侧边栏的设计。这个更新旨在提高断点调试的效率，通过提供更好的断点概览、更直观易用的用户工作流程和更可见的断点特性来实现。更新后的断点侧边栏集中于使现有功能更加直观易用，而非添加新功能。更新后的功能包括：暂停异常以调查代码错误、管理断点（展开相关断点组、折叠其他组、单击跳转到代码位置、删除或启用 / 禁用断点）以及使用条件断点和日志点等不太常用的断点特性。如果您有进一步的建议或反馈，请通过 crbug.com 提交。同时，建议使用 Chrome Canary、Dev 或 Beta 版本作为默认开发浏览器，以获得最新的 DevTools 功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[“const” 欺骗]]></title>
        <id>https://www.joshwcomeau.com/javascript/the-const-deception/</id>
        <link href="https://www.joshwcomeau.com/javascript/the-const-deception/"/>
        <updated>2023-04-25T00:12:35.864Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshwcomeau.com/javascript/the-const-deception/">The “const” Deception</a></p><p><strong>概要：</strong></p><p>本文介绍了 JavaScript 中的 const 关键字，它用于声明常量。虽然 const 声明的对象是不可重新赋值的，但我们仍然可以修改该对象的属性或元素。文章讲解了变量名作为标签、重新分配标签和修改数据等概念，并介绍了原始数据类型的特点。最后，作者推荐了一些深入学习 JavaScript 的资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年，Rust 能否击败 JavaScript？]]></title>
        <id>https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023</id>
        <link href="https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023"/>
        <updated>2023-04-24T08:43:58.611Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023">Can Rust Beat JavaScript in 2023?</a></p><p><strong>概要：</strong></p><p>本文介绍了 Rust 作为 Web 开发语言的优势。尽管在过去，一些人认为使用 Rust 前端开发（通过 WASM）比 JavaScript 慢或者不够成熟，但是现在已经不再是问题。实际测试表明，Rust WASM 框架如 Leptos 和 Dioxus 在性能上超越了大多数 JavaScript 框架，同时 Rust 也有着出色的后端性能，在 TechEmpower 的排名中占据了五个前十名的位置。此外，Rust 还具有良好的开发体验和错误处理机制，并且拥有完善的生态系统来支持数据库、Redis、Stripe 支付等服务。最后，文章介绍了 Shuttle 作为部署 Rust 应用的工具。总之，Rust 是一个非常值得使用的 Web 开发语言，可以提供更好的性能、更低的内存占用和更好的服务稳定性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[职业建议：辞职时提前通知很重要]]></title>
        <id>https://davidlaprade.github.io/give-a-lot-of-notice</id>
        <link href="https://davidlaprade.github.io/give-a-lot-of-notice"/>
        <updated>2023-04-24T01:03:24.977Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://davidlaprade.github.io/give-a-lot-of-notice">Career Advice No One Gave Me: Give a Lot of Notice When You Quit</a></p><p><strong>概要：</strong></p><p>在辞职时，通常给予两周的提前通知是黄金标准。但是，给予更长时间的通知实际上有很多好处。这些好处包括：只做自己最喜欢的工作部分、消除所有工作压力、获得相同的薪水、延长福利期限、休假时间没有使用、股票归属权增加、获得奖金、留下积极的印象、受到感谢和赞赏等。如果你是一名能干的软件工程师，并且在公司中地位良好，那么给予超过两周的通知通常对所有人都是有利的。此外，给予更长时间的通知还可以使公司更顺利地进行转型，减少风险等。

为什么公司会同意这样做呢？通常情况下，需要签署延长通知期的人是工程师的经理，可能还包括人力资源部门。但是，如果你的</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[是时候学习 oklch 颜色了。]]></title>
        <id>https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/</id>
        <link href="https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/"/>
        <updated>2023-04-24T01:01:10.314Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/">It's time to learn oklch color</a></p><p><strong>概要：</strong></p><p>本文介绍了最新的 CSS 颜色标记法，包括 hwb ()、lab ()、lch ()、oklab ()、oklch () 和 color ()。文章推荐学习 oklch () 标记法，因为它基于人眼感知而不是技术限制，可以定义任何颜色，并且支持更广泛的色域。此外，文章还提到了使用 oklch () 时需要注意的一些问题，如 chroma 值的范围和 hue 值的变化等。最后，文章推荐了一个在线颜色选择器 oklch.com，方便调试和转换其他颜色格式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[批判性思维是软件工程师最重要的技能吗？]]></title>
        <id>https://blog.pragmaticengineer.com/critical-thinking/</id>
        <link href="https://blog.pragmaticengineer.com/critical-thinking/"/>
        <updated>2023-04-24T01:00:31.080Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.pragmaticengineer.com/critical-thinking/">Is Critical Thinking the Most Important Skill for Software Engineers?</a></p><p><strong>概要：</strong></p><p>这篇文章谈到了两个现象：技术术语的使用和 “思想领袖” 在社交媒体上的崛起，以及这些现象对批判性思维的影响。作者认为，过度使用技术术语可能掩盖了人们对某一概念的真正理解，而 “思想领袖” 的观点也不应该被轻易地接受，需要进行深入的研究和验证。作者建议人们提高批判性思维能力，包括理解技术术语、验证信息、问 “为什么” 和 “如何”，并避免跟风。最后，作者强调批判性思维将在未来变得越来越重要，因为随着人工智能工具的普及，我们需要更多的人来质疑和思考。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么你应该在社区大学教书]]></title>
        <id>https://timozander.de/blog/why-you-should-teach/</id>
        <link href="https://timozander.de/blog/why-you-should-teach/"/>
        <updated>2023-04-24T00:36:52.865Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://timozander.de/blog/why-you-should-teach/">Why you should teach at a Community College</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了作者作为软件开发者教授 IT 课程的经历，并总结了教学对于软件开发者的好处。首先，教学可以帮助开发者更好地了解普通用户的需求和使用习惯，从而改善软件的用户体验；其次，教学可以提高开发者的语言表达能力，让他们更好地将复杂概念简单易懂地传达给学生；最后，教学本身也是一种学习，通过教学可以不断提升自己的技能和知识水平。作者建议开发者在编写指导文档时要详细、清晰地说明每一个步骤，同时要注意避免使用过多的技术术语和缩略语。此外，作者还鼓励有志于成为教师的人士加入到 STEM 教育中来，为缓解教师短缺问题做出贡献。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么在 React 中你不需要信号（Signals）]]></title>
        <id>https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/</id>
        <link href="https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/"/>
        <updated>2023-04-24T00:36:07.525Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/">Why You Don't Need Signals in React</a></p><p><strong>概要：</strong></p><p>本文介绍了信号在 React 中的两个方面：反应式原语和绕过 diffing。反应式是 React 的一个关键特性，可以通过 useState 创建反应式原语来定义状态，并触发重新渲染。为了简化全局状态的定义和使用，第三方库 Jotai 可以很有用。Jotai 提供了 atoms 来定义全局状态，这些 atoms 可以表示状态的定义，也可以定义依赖于其他 atoms 的派生状态。与 useState 不同，useAtom 不是局部状态，可以在另一个组件中使用来共享 atom 状态。另一个重要的特性是绕过 diffing。React 通过比较 UI 的先前和当前表示来更新 DOM，以确定已更改的内容并仅更新 DOM 的那些部分，从而实现更好的性能和响应性。然而，绕过 diffing 可能会导致 UI 不一致，并使应用程序更难理解。因此，在决定绕过 diffing 之前，需要全面评估性能收益并权衡潜在风险。总之，Jotai 提供了一种更简单</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[说不要 "闪烁" 的 UI：使用 useLayoutEffect，绘画和浏览器故事]]></title>
        <id>https://www.developerway.com/posts/no-more-flickering-ui</id>
        <link href="https://www.developerway.com/posts/no-more-flickering-ui"/>
        <updated>2023-04-24T00:34:43.692Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/no-more-flickering-ui">Say no to "flickering" UI: useLayoutEffect, painting and browsers story</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中如何根据 DOM 测量更改元素的基础知识。文章首先通过一个响应式导航组件的例子，讲解了如何使用 useEffect 来计算容器大小和每个元素的尺寸，并且根据这些信息来调整元素的数量。然而，这种方法会导致初始渲染时出现闪烁问题。为了解决这个问题，文章介绍了 useLayoutEffect 的用法，并解释了浏览器渲染、绘制和事件循环等相关概念。最后，文章还讨论了在 Next.js 等服务器端渲染框架中使用 useLayoutEffect 的问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🔥 掌握 ReactJS 优化 - ITNEXT]]></title>
        <id>https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f</id>
        <link href="https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f"/>
        <updated>2023-04-24T00:19:26.031Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f">🔥 Mastering ReactJS optimization - ITNEXT</a></p><p><strong>概要：</strong></p><p>本文介绍了一些优化 React 应用程序的关键技术。首先，文章列举了常见的性能瓶颈，如大型包大小、慢渲染和网络请求不优化等。接着，文章介绍了一些优化策略，包括代码分割、懒加载、记忆化、分析器和服务器端渲染。通过掌握这些技术，可以创建快速响应、用户体验良好的 React 应用程序。其中，代码分割是将代码拆分成小块，在需要时按需加载，从而减少初始加载时间的强有力的优化技术；懒加载则是仅在需要时加载模块，而不是预加载所有内容，同样可以提高应用程序的性能。此外，文章还介绍了记忆化、分析器和服务器端渲染等其他优化技术。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们如何让 Vite 4.3 更快]]></title>
        <id>https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html</id>
        <link href="https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html"/>
        <updated>2023-04-22T02:32:50.851Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html">How we made Vite 4.3 faaaaster</a></p><p><strong>概要：</strong></p><p>Vite 4.3 是一个快速的 JavaScript 构建工具，它在性能方面进行了改进。这篇文章介绍了 Vite 4.3 是如何通过优化解析策略、使用异步函数、并行处理和 JavaScript 优化等方式来提高性能的。此外，该文章还介绍了一些与 Vite 4.3 相关的基准测试生态系统和插件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 v5.80.0・webpack/webpack]]></title>
        <id>https://github.com/webpack/webpack/releases/tag/v5.80.0</id>
        <link href="https://github.com/webpack/webpack/releases/tag/v5.80.0"/>
        <updated>2023-04-21T02:20:51.852Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/webpack/webpack/releases/tag/v5.80.0">Release v5.80.0 · webpack/webpack</a></p><p><strong>概要：</strong></p><p>本文介绍了 Webpack v5.80.0 的更新内容，包括新增功能、Bug 修复、测试和贡献者体验、开发者体验以及依赖项和维护等方面。新增功能包括支持在 import.meta 中使用解构赋值、支持带有 AwaitExpression 的解构赋值的树摇、引入 errorsSpace 和 warningsSpace 以获得更可读的跟踪信息等。Bug 修复主要涉及 CSS 相关问题、语法错误、模块 ID 分配等。此外，还对测试用例进行了完善，优化了开发者体验，并更新了一些依赖项。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deno vs. Node：没有人准备好迎接这个变化 | .cult by Honeypot]]></title>
        <id>https://cult.honeypot.io/reads/deno-vs-node-main-differences/</id>
        <link href="https://cult.honeypot.io/reads/deno-vs-node-main-differences/"/>
        <updated>2023-04-21T00:30:49.371Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cult.honeypot.io/reads/deno-vs-node-main-differences/">Deno vs. Node: No One is Ready for the Move | .cult by Honeypot</a></p><p><strong>概要：</strong></p><p>本文介绍了 Node.js 和 Deno 两个 JavaScript 运行环境的比较。Node.js 是一个流行的服务器端、开源、跨平台的 JavaScript 运行环境，自 2009 年以来一直占据着 Web 开发世界的主导地位。它专注于事件驱动的 HTTP 服务器，并使用单线程的事件循环处理请求。与大多数竞争对手不同的是，Node.js 基于回调函数的扩展机制可以在最小内存使用下处理更多的请求。相比之下，Deno 在设计上有所改进，提供了更安全的框架和现代特性，由 Node.js 的创始人 Ryan Dahl 推出。然而，尽管 Deno 解决了 Node.js 的一些设计缺陷，但采用 Deno 的速度非常缓慢，大多数开发人员仍然满意于 Node.js。本文将探讨这种现象背后的原因，并对 Node.js 和 Deno 进行比较，从第三方包管理、API、安全性和 TypeScript 支持等方面进行分析。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Rust 1.69.0 | Rust 博客]]></title>
        <id>https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html</id>
        <link href="https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html"/>
        <updated>2023-04-21T00:20:26.179Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html">Announcing Rust 1.69.0 | Rust Blog</a></p><p><strong>概要：</strong></p><p>Rust 1.69.0 版本发布，包含 3000 多个提交和 500 多个贡献者的小改进。其中，Cargo 现在建议自动修复一些警告，支持自动修复一些简单的 Clippy 警告。为了吸引更多关注，当检测到可以自动修复的警告时，Cargo 将建议运行 cargo fix 或 cargo clippy --fix。此外，为了提高编译速度，默认情况下不再在构建脚本中包含调试信息。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Vite 4.3。]]></title>
        <id>https://vitejs.dev/blog/announcing-vite4-3.html</id>
        <link href="https://vitejs.dev/blog/announcing-vite4-3.html"/>
        <updated>2023-04-20T14:49:02.877Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vitejs.dev/blog/announcing-vite4-3.html">Announcing Vite 4.3</a></p><p><strong>概要：</strong></p><p>Vite 4.3 发布，主要改进了开发服务器的性能。该版本优化了解析逻辑，改进了热路径，并实现了智能缓存，以查找 package.json、TS 配置文件和已解决的 URL。与 Vite 4.2 相比，这次更新在各方面都有速度提升。此外，该团队正在开发一个官方基准测试工具，以获取每个 Pull Request 的性能指标，并通过 vite-plugin-inspect 提供更多的性能相关功能来帮助用户识别应用程序的瓶颈。明年他们将发布 Vite 5，这将是今年唯一的 Vite 主要版本，同时也会放弃对 Node.js 14 和 16 的支持。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 npm 包 provenance | GitHub 博客]]></title>
        <id>https://github.blog/2023-04-19-introducing-npm-package-provenance/</id>
        <link href="https://github.blog/2023-04-19-introducing-npm-package-provenance/"/>
        <updated>2023-04-20T07:15:21.619Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-04-19-introducing-npm-package-provenance/">Introducing npm package provenance | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub has added a feature to its Actions tool that enables developers to publish provenance alongside their npm projects. The feature provides a verifiable link between a package and its source repository, as well as the build instructions used to publish it. The aim is to increase trust in open source projects by enabling developers to ensure the integrity of their software supply chain. The Supply-chain Levels for Software Artifacts (SLSA) specification was created for this purpose and is being used for GitHub's npm provenance statements. The company also requires packages to be built on a trusted CI/CD platform.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何编写类型安全的 CSS 模块 - LogRocket 博客]]></title>
        <id>http://blog.logrocket.com/write-type-safe-css-modules/</id>
        <link href="http://blog.logrocket.com/write-type-safe-css-modules/"/>
        <updated>2023-04-20T04:51:28.985Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="http://blog.logrocket.com/write-type-safe-css-modules/">How to write type-safe CSS Modules - LogRocket Blog</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 TypeScript 自动化 CSS Modules 类型定义。CSS Modules 提供了一种在现代 Web 应用程序中编写模块化和作用域 CSS 样式的方法，但是类名在运行时生成并且在构建之间更改，因此很难以类型安全的方式使用它们。手动创建每个 CSS Module 的类型定义文件更新繁琐，容易出错。本文介绍了如何使用 typed-css-modules 包自动生成类型定义，并提供脚本来验证生成的类型是否是最新的。通过自动化这些过程，可以减少开发人员对类型系统的不信任感，让团队专注于构建优秀的产品。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 20 现已推出！| Node.js]]></title>
        <id>https://nodejs.org/en/blog/announcements/v20-release-announce</id>
        <link href="https://nodejs.org/en/blog/announcements/v20-release-announce"/>
        <updated>2023-04-20T04:50:59.309Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nodejs.org/en/blog/announcements/v20-release-announce">Node.js 20 is now available! | Node.js</a></p><p><strong>概要：</strong></p><p>Node.js 20 发布了，其中包括了新的 Node.js 权限模型、同步 import.meta.resolve、稳定的测试运行器、更新到 V8 JavaScript 引擎 11.3 版本和 Ada 到 2.0 等。此次更新还包括对基础部分的改进，如 URL、fetch () 和 EventTarget 等。值得注意的是，Permission Model 是一项实验性机制，用于在执行期间限制对特定资源的访问。该项目继续在多个领域取得进展，许多新功能和修复已流入现有的 LTS 版本中。</p>]]></content>
    </entry>
</feed>
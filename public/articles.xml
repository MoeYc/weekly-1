<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-05-05T01:13:52.988Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[使用 Vercel Spaces 实现规模化的高质量软件 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-spaces</id>
        <link href="https://vercel.com/blog/vercel-spaces"/>
        <updated>2023-05-05T00:18:14.981Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-spaces">Quality software at scale with Vercel Spaces – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel推出了Vercel Spaces，它提供了强大的工具和惯例，可以与monorepo设置集成，使开发人员能够在保持质量的同时有效地扩展。Spaces仪表板提供了对开发工作流程、代码健康状况和构建日志的洞察力，并包括通过Conformance、Code Owners和Vercel Runs提升效率和消除障碍的新功能。Conformance可以在开发生命周期的早期自动检测前端产品的关键问题，Code Owners可以帮助确定谁对代码负责，并确保代码变更由正确的人审查，而Vercel Runs通过交互式用户界面提供了一种更简单的调试任务的方式。Vercel Spaces可供Vercel企业客户提前使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular v16 已经发布了！- Angular 博客]]></title>
        <id>https://blog.angular.io/angular-v16-is-here-4d7a28ec680d</id>
        <link href="https://blog.angular.io/angular-v16-is-here-4d7a28ec680d"/>
        <updated>2023-05-05T00:03:11.942Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.angular.io/angular-v16-is-here-4d7a28ec680d">Angular v16 is here! - Angular Blog</a></p><p><strong>概要：</strong></p><p>Angular 发布了最大的版本更新，包括改进响应性、服务器端渲染和工具等方面。其中最重要的是引入了全新的响应性模型，提高了性能和开发者体验。该版本还支持服务端渲染和水合，提供了更好的工具和单独的 API，以及其他许多改进。此外，Angular 还计划在未来一年内推出更多的改进和功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TailwindCSS vs. UnoCSS

TailwindCSS 与 UnoCSS]]></title>
        <id>https://dev.to/mapleleaf/tailwindcss-vs-unocss-2a53</id>
        <link href="https://dev.to/mapleleaf/tailwindcss-vs-unocss-2a53"/>
        <updated>2023-05-05T00:02:05.363Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dev.to/mapleleaf/tailwindcss-vs-unocss-2a53">TailwindCSS vs. UnoCSS</a></p><p><strong>概要：</strong></p><p>本文对比了 TailwindCSS 和 UnoCSS 两个工具，总结了它们的特点、语言、文档、自定义样式和编辑器支持等方面。TailwindCSS 拥有完整的 CSS 特性类名，可以通过任意值、变体和属性来进行全面的样式设计，而 UnoCSS 则支持所有 TailwindCSS 的功能，并提供了一些额外的功能，如变体组、CSS 网格流体列和更多动画效果。在语言方面，TailwindCSS 有一个相对规范的类名命名方式，UnoCSS 则更加灵活。在文档和自定义样式方面，两者都有不错的表现，但 UnoCSS 的交互式文档和颜色提示更加出色。在编辑器支持方面，TailwindCSS 支持较好，但存在一些缺陷，而 UnoCSS 的高亮显示和颜色提示则更为出色。作者认为，如果你看重灵活性和额外的功能，你可能会喜欢 UnoCSS，但如果你看重约束和更清晰的编写语言，则应该选择</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 13.4]]></title>
        <id>https://nextjs.org/blog/next-13-4</id>
        <link href="https://nextjs.org/blog/next-13-4"/>
        <updated>2023-05-04T23:58:36.281Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nextjs.org/blog/next-13-4">Next.js 13.4</a></p><p><strong>概要：</strong></p><p>Next.js 13.4 是一个重要的版本，标志着 App Router 的稳定性。这个版本增加了许多新特性，包括 React Server Components、嵌套路由和布局、简化数据获取、流式渲染和 Suspense、内置 SEO 支持等。其中最重要的是 App Router，它是 Next.js 的核心组件，可以让开发者更方便地定义页面布局和数据获取方式。此外，Turbopack 也是一个值得关注的新功能，它可以加速本地开发和生产构建过程。最后，Server Actions 是一个实验性的功能，可以在服务器端直接修改数据，不需要客户端 JavaScript。总之，Next.js 13.4 为开发者提供了更强大的工具，帮助他们更轻松地构建动态、个性化和全球化的 Web 应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何测试您的类型]]></title>
        <id>https://www.totaltypescript.com/how-to-test-your-types</id>
        <link href="https://www.totaltypescript.com/how-to-test-your-types"/>
        <updated>2023-05-04T12:52:44.759Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.totaltypescript.com/how-to-test-your-types">How to test your types</a></p><p><strong>概要：</strong></p><p>本文介绍了三种测试 TypeScript 类型的方法。首先是使用 vitest，这是一个基于 Vite 的强大测试运行器，可以用来测试运行时代码和类型。其次是自己编写测试代码，可以使用 Expect 和 Equal 等类型帮助工具来测试特定类型，并在测试套件中运行 tsc 检查类型测试是否失败。最后，还介绍了一个名为 tsd 的库，它与 vitest 很相似，但包含了所有必要的内容，使得测试更加方便。对于应用程序开发而言，测试类型并不是必须的，但对于任何将被大量人使用的库而言，测试类型是至关重要的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 种使用 ChatGPT 学习更好的方法 - 斯科特・H・扬]]></title>
        <id>https://www.scotthyoung.com/blog/2023/05/02/chatgpt-learning-tips/</id>
        <link href="https://www.scotthyoung.com/blog/2023/05/02/chatgpt-learning-tips/"/>
        <updated>2023-05-04T09:01:50.070Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.scotthyoung.com/blog/2023/05/02/chatgpt-learning-tips/">10 Ways You Can Use ChatGPT to Learn Better - Scott H Young</a></p><p><strong>概要：</strong></p><p>这篇文章总结了读者们如何使用大型语言模型（LLMs）来学习和研究的建议，并探讨了使用这些工具的优缺点。作者提醒读者要注意，虽然 ChatGPT 可以进行人类般的对话，但它并不是真正的人类，有时会提供错误的答案。然而，ChatGPT 在许多任务上都很有用，例如作为个人导师、语言教练、生成摘要、与长文本对话、简化专业术语等。作者还提到了一些不应该使用 AI 工具的情况，例如期望它们正确地获取事实、引用和数学等方面。最后，作者邀请读者分享他们使用 ChatGPT 或其他 AI 工具进行学习的经验和建议。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Canaries：在 Meta 之外启用增量功能发布的 React]]></title>
        <id>https://react.dev/blog/2023/05/03/react-canaries</id>
        <link href="https://react.dev/blog/2023/05/03/react-canaries"/>
        <updated>2023-05-04T06:53:29.142Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://react.dev/blog/2023/05/03/react-canaries">React Canaries: Enabling Incremental Feature Rollout Outside Meta – React</a></p><p><strong>概要：</strong></p><p>React 团队推出了一个新的官方支持的 Canary 版本，让开发者可以在稳定版本发布之前就采用新功能。这个 Canary 版本只包含 React 团队相信已经准备好被采用的特性，而不像实验性版本那样可能会有重大变化。Canary 版本可以让框架在全局 React 发布计划之外单独采用 React 特性，也可以让框架在自己的次要版本中发布 React 相关的重大变更，而不会破坏 semver。React 将按照 semver 规范每个稳定版本进行更新，同时也会在博客上发布 Canary 版本中的重大变更和新特性。Canary 版本需要被固定版本号，以避免包含重大变更。除此之外，React 的稳定版本不会有任何改变。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个文件中多个样式表・Issue #5629・w3c/csswg-drafts]]></title>
        <id>https://github.com/w3c/csswg-drafts/issues/5629</id>
        <link href="https://github.com/w3c/csswg-drafts/issues/5629"/>
        <updated>2023-05-04T04:50:11.466Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/w3c/csswg-drafts/issues/5629">Multiple stylesheets per file · Issue #5629 · w3c/csswg-drafts</a></p><p><strong>概要：</strong></p><p>这篇文章讨论了在 JS 中导入 CSSStyleSheets 的问题。目前的解决方法是将 CSS 编译为 JS 模块，但这会降低浏览器直接加载和解析 CSS 的性能。Web Bundles 可能会通用地解决这个问题，但其未来在多个浏览器上的应用尚不确定。作者提出了一个新的解决方案：引入一个 @sheet 规则，它包含整个样式表作为其内容，以允许 CSS 的打包。该提议对于管理 JS 中的 CSSStyleSheets 的代码最为相关，并且也可以作为用户自定义 CSS 加载程序的桥梁，通过标准化打包，可以使用客户端实用程序进行作用域限定。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[熊猫 CSS - 无运行时开销的 CSS-in-JS]]></title>
        <id>https://infinum.com/blog/panda-css-css-in-js-without-runtime-overhead/</id>
        <link href="https://infinum.com/blog/panda-css-css-in-js-without-runtime-overhead/"/>
        <updated>2023-05-04T04:49:11.860Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://infinum.com/blog/panda-css-css-in-js-without-runtime-overhead/">Panda CSS – CSS-in-JS without Runtime Overhead</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 Panda CSS 的前端工具库，它提供了一组实用类、模式和配方，用于在 Web 应用程序中构建现代和响应式用户界面。相比于纯字符串的方法，Panda CSS 提供了一种声明性的方法来使用 JavaScript 对象对组件进行样式设置，使其更易读和易维护。此外，本文还介绍了如何在 Next.js 项目中使用 Panda CSS，并探讨了其主题、模式和配方等高级用法。最后，本文指出，尽管 Panda CSS 目前仍处于实验阶段，但它有望成为前端开发流程中的重要组成部分。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么我喜欢使用地图（和 WeakMaps）来处理 DOM 节点]]></title>
        <id>https://www.macarthur.me/posts/maps-for-dom-nodes</id>
        <link href="https://www.macarthur.me/posts/maps-for-dom-nodes"/>
        <updated>2023-05-04T04:47:53.139Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.macarthur.me/posts/maps-for-dom-nodes">Why I Like Using Maps (and WeakMaps) for Handling DOM Nodes</a></p><p><strong>概要：</strong></p><p>本文介绍了在处理大量 DOM 节点时，Maps（和 WeakMaps）是特别有用的工具的原因。与使用对象作为键 / 值存储相比，使用 Map 可以更简单、更强大、更高效地管理状态，并且不需要设置或读取唯一属性。此外，Map 还具有自动垃圾回收的功能，可以更有效地管理内存。总之，Map 对于处理大量 DOM 节点非常有用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RegExGPT]]></title>
        <id>https://regexgpt.app/</id>
        <link href="https://regexgpt.app/"/>
        <updated>2023-05-04T04:47:06.555Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://regexgpt.app/">RegExGPT</a></p><p><strong>概要：</strong></p><p>RegExGPT 是一种工具，它可以让人们通过输入文本转换的示例和期望结果来生成正则表达式模式。用户还可以使用自然语言输入来解释他们想匹配的模式，并选择输出的编程语言。使用 RegExGPT 时，需要输入要转换的文本示例和期望结果，选择编程语言并点击 “生成” 按钮来生成正则表达式模式。生成的正则表达式模式可以在代码中使用，将输入文本转换为期望的结果。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 React Native macOS 0.71 | React Native]]></title>
        <id>https://devblogs.microsoft.com/react-native/2023-04-27-announcing-macos-71/</id>
        <link href="https://devblogs.microsoft.com/react-native/2023-04-27-announcing-macos-71/"/>
        <updated>2023-05-04T04:42:51.689Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://devblogs.microsoft.com/react-native/2023-04-27-announcing-macos-71/">Introducing React Native macOS 0.71 | React Native</a></p><p><strong>概要：</strong></p><p>React Native macOS 发布了 0.71 版本，这是该平台首次与 iOS、Android 和 Windows 保持同步。为了实现这个目标，开发团队不得不跳过了一些中间版本，并开始着手 0.72 版本。此外，该版本还加入了对 Fabric 的实验性支持，但需要注意的是这只是一个概念验证，存在不稳定性。除此之外，该版本也进行了许多清理和修复工作，以使未来的发布更加顺畅。具体变化请参考 GitHub Release。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebContainers 现在可以在 Safari、iOS 和 iPadOS 上运行。]]></title>
        <id>https://blog.stackblitz.com/posts/webcontainers-are-now-supported-on-safari/</id>
        <link href="https://blog.stackblitz.com/posts/webcontainers-are-now-supported-on-safari/"/>
        <updated>2023-05-04T04:37:40.445Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.stackblitz.com/posts/webcontainers-are-now-supported-on-safari/">WebContainers now run on Safari, iOS, and iPadOS</a></p><p><strong>概要：</strong></p><p>StackBlitz 宣布其 WebContainers 已经可以在 Safari、iOS 和 iPadOS 上运行。用户现在可以在 iPhone 或 iPad 上尝试交互式代码示例和 playground，Safari 支持目前处于 beta 版本。StackBlitz 的 WebContainers 是基于未来技术构建的，包括 Wasm threads 和 SharedArrayBuffer，这些技术在 Safari 上得到了支持。WebContainers 在复杂项目中的运行速度比本地快得多，StackBlitz 团队仍在不断优化。此外，StackBlitz 团队通过加入 Bytecode Alliance，致力于推动 Web 技术的发展。用户可以在所有最新的桌面浏览器上使用 WebContainers，包括 Chrome、Firefox 和 Safari，对于移动设备而言，Android 上的 Chrome、Chromium-based 浏览器和 Firefox 可以使用 WebContainers，iOS 和 iPadOS 上的 Safari 目前处于 beta 版本。StackBlitz 团队将继续改进 WebContainers，并计划在今年内推出一系列重大更新。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 React 服务器组件在您的博客上显示一个视图计数器。]]></title>
        <id>https://scastiel.dev/view-counter-react-server-components</id>
        <link href="https://scastiel.dev/view-counter-react-server-components"/>
        <updated>2023-05-04T04:36:19.199Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://scastiel.dev/view-counter-react-server-components">Display a view counter on your blog with React Server Components</a></p><p><strong>概要：</strong></p><p>本文介绍了如何在个人博客中使用 React Server Components、Streaming 和 Suspense 实现浏览量计数器。作者使用 Plausible 工具的 API 获取页面的浏览量，然后将其渲染到页面上。传统的方法是在客户端和服务器之间进行通信，但是使用 React Server Components 可以更加优雅地处理这个问题。通过在 <PageViews /> 组件中调用 getCountForPage 函数，然后在页面.tsx 文件中渲染计数，可以实现此目的。而使用 Streaming 则可以让服务器先发送一个初始版本的页面，然后保持连接打开，并稍后发送第二个版本（包含浏览量）。最终，读者将看到完整的页面，其中包括浏览量计数器。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 React 中编写注释：好的、坏的和丑陋的]]></title>
        <id>https://dmitripavlutin.com/react-comments/</id>
        <link href="https://dmitripavlutin.com/react-comments/"/>
        <updated>2023-05-04T04:35:39.416Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dmitripavlutin.com/react-comments/">How to Write Comments in React: The Good, the Bad and the Ugly</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了在 React 中添加注释的三种方法。第一种是使用 JSX 注释语法，但这种方式有些冗长；第二种是在 JSX 标签外使用 JavaScript 注释，可以更简洁地添加注释；第三种是在 JSX 标签内部使用 JavaScript 注释，可以针对特定元素添加注释。作者认为第三种方法最好，因为它简洁明了且针对性强。总之，读者可以根据自己的喜好选择合适的注释方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 v6.11.0・remix-run/react-router]]></title>
        <id>https://github.com/remix-run/react-router/releases/tag/react-router%406.11.0</id>
        <link href="https://github.com/remix-run/react-router/releases/tag/react-router%406.11.0"/>
        <updated>2023-05-04T02:58:08.940Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/remix-run/react-router/releases/tag/react-router%406.11.0">Release v6.11.0 · remix-run/react-router</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了 React Router 版本 6.11.0 的更新内容。其中，一些小的改动包括在 useFetcher 中启用 basename 支持，更新 @remix-run/router 依赖等。在补丁方面，使用 RouterProvider 时，通过 @remix-run/router 实例处理相对路由，可以稳定地使用 useNavigate/useSubmit/fetcher.submit，而 BrowserRouter 仍然依赖于 useLocation ()，因此这些钩子在位置更改时仍不稳定。此外，fetchers 不再在搜索参数更改或路由到相同 URL 时重新验证，并且只会在操作提交或 router.revalidate 调用时重新验证。还修复了一些错误，如使用 Component 而不是 element 时的重新渲染问题，<Link to="//"> 和其他无效 URL 值的优雅失败等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Qwik 达到了 v1.0 版本。]]></title>
        <id>https://www.builder.io/blog/qwik-v1</id>
        <link href="https://www.builder.io/blog/qwik-v1"/>
        <updated>2023-05-04T02:57:48.314Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/qwik-v1">Qwik Reaches v1.0</a></p><p><strong>概要：</strong></p><p>Qwik 是一个全栈 Web 框架，旨在通过 JavaScript 流式传输和延迟执行等技术提供快速、可扩展和易维护的 Web 应用程序。它借鉴了 React、Vue、Angular、Svelte 等框架的优点，并提供了一套强大的工具集，使开发人员能够快速高效地构建 Web 应用程序。Qwik 还提供了许多功能，包括 JSX、基于目录的路由、数据获取、中间件逻辑、UI 组件、国际化、身份验证、CMS、样式和测试等。此外，Qwik 社区不断增长，为开发人员提供了支持和协作的平台。如果想要尝试使用 Qwik，可以查看其入门页面、教程或 Stackblitz。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[即时工程 vs 盲目提示]]></title>
        <id>https://mitchellh.com/writing/prompt-engineering-vs-blind-prompting</id>
        <link href="https://mitchellh.com/writing/prompt-engineering-vs-blind-prompting"/>
        <updated>2023-05-04T02:52:35.944Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://mitchellh.com/writing/prompt-engineering-vs-blind-prompting">Prompt Engineering vs. Blind Prompting</a></p><p><strong>概要：</strong></p><p>本文介绍了 Prompt Engineering，即利用提示来有效地从语言模型中提取信息的过程，通常用于实际应用。文章指出，许多人声称正在进行 Prompt Engineering，但实际上只是盲目提示。因此，本文提供了一种基于实验方法的 Prompt Engineering 示例，以展示如何为应用程序构建可靠的功能。作者强调了选择问题、演示集、提示候选项和测试提示等步骤的重要性，并解释了如何选择最终的提示方案。最后，作者呼吁更多的实验研究来支持 Prompt Engineering 技术的发展。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Rust 在 10 分钟或更短的时间内构建和部署 URL 缩短器]]></title>
        <id>https://www.shuttle.rs/blog/2022/03/13/url-shortener</id>
        <link href="https://www.shuttle.rs/blog/2022/03/13/url-shortener"/>
        <updated>2023-05-04T02:48:50.993Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.shuttle.rs/blog/2022/03/13/url-shortener">Building and Deploying a URL shortener with Rust in 10 minutes or less</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了一个软件开发人员在凌晨时分突然想到的一个想法：能否在不需要担心基础架构的情况下快速构建一个有用的应用程序。他使用了 Rust 编程语言，结合 serverless 平台 Shuttle 和 Postgres 数据库，最终成功地构建了一个简单的 URL 缩短服务。作者认为，虽然现实中的软件工程很复杂，涉及到不同团队和技能集的协作，但这种新型的无需关注基础架构的开发模式是可行的，并且可以带来更好的体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么到了 2023 年，OAuth 仍然很难？| Nango 博客]]></title>
        <id>https://www.nango.dev/blog/why-is-oauth-still-hard</id>
        <link href="https://www.nango.dev/blog/why-is-oauth-still-hard"/>
        <updated>2023-05-04T02:48:20.045Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.nango.dev/blog/why-is-oauth-still-hard">Why is OAuth still hard in 2023? | Nango Blog</a></p><p><strong>概要：</strong></p><p>OAuth 是一个标准协议，但在实际应用中，每个 API 都有自己的解释和实现方式，使得 OAuth 变得非常复杂。许多 API 还添加了非标准扩展，使得调试变得困难。此外，许多 API 需要进行审核才能使用，并且 OAuth 安全性也是一个不断变化的目标。为了解决这些问题，Nango 正在开发一种新的方法，该方法提供预构建的 OAuth 流程、安全令牌存储和自动令牌刷新，支持超过 90 个 OAuth API。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[朝着更好的 1 对 1：一个尴尬的宣言]]></title>
        <id>https://tylercipriani.com/blog/2023/04/22/better-1on1s/</id>
        <link href="https://tylercipriani.com/blog/2023/04/22/better-1on1s/"/>
        <updated>2023-05-04T02:47:00.683Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tylercipriani.com/blog/2023/04/22/better-1on1s/">Towards better 1-on-1s: an awkward manifesto</a></p><p><strong>概要：</strong></p><p>本文介绍了一种有效的 1-on-1s（一对一会议）流程，以帮助工程管理人员和个人贡献者更好地进行每周例会。作者提供了一个简单的 POP（目的、结果、过程）日程安排，包括检查团队成员的状况、更新目标、更新 “自夸文档”、给予反馈等内容。此外，作者还分享了自己的笔记和待办事项系统，以及一些有趣的问题来引导讨论。最后，作者指出成功的 1-on-1s 的关键在于真正关心你的直接报告，才能获得他们的关注和参与。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我想谈谈 WebGPU。]]></title>
        <id>https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu</id>
        <link href="https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu"/>
        <updated>2023-05-04T02:40:46.869Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu">I want to talk about WebGPU</a></p><p><strong>概要：</strong></p><p>WebGPU 是一种新的 WebGL，可以在 Web 浏览器中绘制 3D。它很好用，甚至可能取代 Canvas 成为 Web 浏览器中绘制 2D 的新方式，并取代 Vulkan 和 OpenGL 成为任何编程语言中绘制的标准方式。WebGPU 已经在 Chrome 113 中发布，到年底将会在所有浏览器中普及。对于程序员来说，使用 WebGPU 需要构建一个或多个管道对象，描述 “我运行哪些着色器，以及可以输入什么样的数据” 等信息。此外，WebGPU 提供了 JavaScript、Rust/C++ 等多种语言实现方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Vercel 上的存储功能 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-storage</id>
        <link href="https://vercel.com/blog/vercel-storage"/>
        <updated>2023-05-04T01:58:00.921Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-storage">Introducing storage on Vercel – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel宣布了一套无服务器存储解决方案，包括Vercel KV，一个无服务器的Redis解决方案；Vercel Postgres，一个为前端建立的无服务器SQL数据库；以及Vercel Blob，一个在边缘上传和服务文件的解决方案。这些解决方案旨在使数据库成为Vercel前端云的一流部分，并使开发人员能够管理他们的前端存储需求，而不必担心基础设施。此举是由性能和个性化的需求所驱动的，因为框架变成了服务器优先和边缘优先，世界也从单体架构转向可组合的架构。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Deno KV。]]></title>
        <id>https://deno.com/blog/kv</id>
        <link href="https://deno.com/blog/kv"/>
        <updated>2023-05-04T01:56:27.393Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/kv">Announcing Deno KV</a></p><p><strong>概要：</strong></p><p>Deno KV 是一款全球复制、强一致性的键值数据库，可在 35 个地区实现低延迟读取。它可以无缝集成到开源 Deno 运行时中，无需任何配置即可在本地或作为托管服务运行。Deno KV 是一个简单但功能强大的一流原语，只暴露了少量方法来存储、检索、删除和枚举数据。它支持原子事务，提供外部一致性和线性化，并可通过 consistency："eventual" 选项放松一致性约束以提高读取操作的响应速度。Deno KV 适用于各种应用场景，如实时协作、用户数据管理和身份验证等。此外，它还提供了一些演示应用程序，如多人井字游戏、像素画板和共享任务列表等，以展示其能力。在未来几个月中，我们将推出更多功能，进一步简化构建和部署应用程序的过程。在 beta 期间，用户可以免费使用最多 1</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自主 GPT-4：从 ChatGPT 到 AutoGPT、AgentGPT、BabyAGI、HuggingGPT 等等。]]></title>
        <id>https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e</id>
        <link href="https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e"/>
        <updated>2023-05-03T10:36:11.064Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e">Autonomous GPT-4: From ChatGPT to AutoGPT, AgentGPT, BabyAGI, HuggingGPT, and Beyond</a></p><p><strong>概要：</strong></p><p>本文介绍了 ChatGPT 和 LLM 技术的兴起，这些先进的语言模型已经引起了开发者、爱好者和组织的广泛关注。为了更好地整合和构建这些先进模型，出现了像 LangChain 和 LlamaIndex 这样的平台。随着自动化任务和 AI 代理越来越多地利用 GPT-4 的能力，这些创新平台正在重新定义我们与 LLMs 互动的方式。本文还介绍了几个基于 GPT-4 的自主 AI 工具和应用，包括 Auto-GPT、AgentGPT、BabyAGI、HuggingGPT、Web LLM、God Mode 和 CAMEL。这些工具和应用可以分为命令行界面（CLI）和基于浏览器的解决方案两类。这些平台正在推动人工智能领域的突破性创新和进步。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 渲染交互指南]]></title>
        <id>https://ui.dev/why-react-renders</id>
        <link href="https://ui.dev/why-react-renders"/>
        <updated>2023-04-27T04:47:36.154Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://ui.dev/why-react-renders">The Interactive Guide to Rendering in React</a></p><p><strong>概要：</strong></p><p>本文主要介绍了 React 的渲染机制，即 React 只有在状态改变时才会重新渲染组件。当事件处理程序被调用时，如果其中包含 useState 的更新函数，并且新状态与快照中的状态不同，React 将触发重新渲染。此外，本文还介绍了 React 的批处理算法和 StrictMode 组件。最后，作者提醒读者，在实际开发中需要注意组件的纯度和性能问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用 Rust 和 Napi rs 在 NodeJs 中将 CSV 文件处理速度提高五倍]]></title>
        <id>https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs</id>
        <link href="https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs"/>
        <updated>2023-04-27T00:47:13.797Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs">How to process a CSV file five times faster in NodeJs with Rust and Napi rs</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Rust 和 Napi rs 在 NodeJs 中处理 CSV 文件。作者使用了 readline 模块来处理 CSV 文件，并记录了处理时间和吞吐量。然后作者使用了 Rust 编写了相同的代码，并通过 pv 命令进行了基准测试，发现 Rust 版本比 Nodejs 版本快五倍。最后，作者介绍了如何使用 Napi rs 将 Rust 代码编译成动态库，并在 Nodejs 中调用。总之，结合 Rust 和 Nodejs 可以实现更好的性能和效率。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 useReducer 的创造性方式]]></title>
        <id>https://www.code-insights.dev/posts/creative-ways-of-using-usereducer</id>
        <link href="https://www.code-insights.dev/posts/creative-ways-of-using-usereducer"/>
        <updated>2023-04-27T00:36:42.149Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.code-insights.dev/posts/creative-ways-of-using-usereducer">Creative ways of using useReducer</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 中的 useReducer 钩子函数，它可以用于管理复杂状态。通过传递一个 reducer 函数、一个初始值和一个可选的初始化函数，useReducer 返回一个包含当前状态和 dispatch 函数的数组。使用 dispatch 函数更新状态时，它会调用 reducer 函数并返回下一个状态。但是，由于函数式 JavaScript 的宽容性质，useReducer 还可以以不同的方式创造性地使用。文章提供了一些例子，如简单的开关、增量按钮、增强状态和安全状态等，演示了使用 useReducer 管理状态的优势。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年在哪里托管您的 Remix 应用程序？]]></title>
        <id>https://www.jacobparis.com/guides/where-to-host-remix</id>
        <link href="https://www.jacobparis.com/guides/where-to-host-remix"/>
        <updated>2023-04-27T00:36:17.402Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.jacobparis.com/guides/where-to-host-remix">Where to host your Remix app in 2023</a></p><p><strong>概要：</strong></p><p>本文介绍了多种应用托管方式，包括无服务器函数、Netlify、Vercel、Cloudflare Pages、Fastly、AWS Lambda 和长期运行的服务器。对于每种托管方式，文章列出了其优点和缺点，以及支持的功能和限制。需要根据自己的应用需求选择适合的托管方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现 experimental_useFormStatus by acdlite・Pull Request #26722・facebook/react]]></title>
        <id>https://github.com/facebook/react/pull/26722</id>
        <link href="https://github.com/facebook/react/pull/26722"/>
        <updated>2023-04-27T00:32:22.463Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/facebook/react/pull/26722">Implement experimental_useFormStatus by acdlite · Pull Request #26722 · facebook/react</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个新的 React Hook，可以读取其祖先表单组件的状态，用于实现加载指示器等功能。目前该 Hook 只在实验通道中可用，随着其稳定性的提高，将会发布更多 API 和文档。该 Hook 内部使用 startTransition 和上下文对象实现，但实际实现细节可能会发生变化。由于表单元素不能嵌套，因此实现者不需要跟踪多个嵌套的 “转换提供者”。虽然它使用通用的 Fiber 配置方法进行实现，但它目前仍基于 React DOM 的要求进行一些假设。</p>]]></content>
    </entry>
</feed>
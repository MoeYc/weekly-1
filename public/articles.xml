<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-05-04T02:53:20.335Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[即时工程 vs 盲目提示]]></title>
        <id>https://mitchellh.com/writing/prompt-engineering-vs-blind-prompting</id>
        <link href="https://mitchellh.com/writing/prompt-engineering-vs-blind-prompting"/>
        <updated>2023-05-04T02:52:35.944Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://mitchellh.com/writing/prompt-engineering-vs-blind-prompting">Prompt Engineering vs. Blind Prompting</a></p><p><strong>概要：</strong></p><p>本文介绍了 Prompt Engineering，即利用提示来有效地从语言模型中提取信息的过程，通常用于实际应用。文章指出，许多人声称正在进行 Prompt Engineering，但实际上只是盲目提示。因此，本文提供了一种基于实验方法的 Prompt Engineering 示例，以展示如何为应用程序构建可靠的功能。作者强调了选择问题、演示集、提示候选项和测试提示等步骤的重要性，并解释了如何选择最终的提示方案。最后，作者呼吁更多的实验研究来支持 Prompt Engineering 技术的发展。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Rust 在 10 分钟或更短的时间内构建和部署 URL 缩短器]]></title>
        <id>https://www.shuttle.rs/blog/2022/03/13/url-shortener</id>
        <link href="https://www.shuttle.rs/blog/2022/03/13/url-shortener"/>
        <updated>2023-05-04T02:48:50.993Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.shuttle.rs/blog/2022/03/13/url-shortener">Building and Deploying a URL shortener with Rust in 10 minutes or less</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了一个软件开发人员在凌晨时分突然想到的一个想法：能否在不需要担心基础架构的情况下快速构建一个有用的应用程序。他使用了 Rust 编程语言，结合 serverless 平台 Shuttle 和 Postgres 数据库，最终成功地构建了一个简单的 URL 缩短服务。作者认为，虽然现实中的软件工程很复杂，涉及到不同团队和技能集的协作，但这种新型的无需关注基础架构的开发模式是可行的，并且可以带来更好的体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么到了 2023 年，OAuth 仍然很难？| Nango 博客]]></title>
        <id>https://www.nango.dev/blog/why-is-oauth-still-hard</id>
        <link href="https://www.nango.dev/blog/why-is-oauth-still-hard"/>
        <updated>2023-05-04T02:48:20.045Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.nango.dev/blog/why-is-oauth-still-hard">Why is OAuth still hard in 2023? | Nango Blog</a></p><p><strong>概要：</strong></p><p>OAuth 是一个标准协议，但在实际应用中，每个 API 都有自己的解释和实现方式，使得 OAuth 变得非常复杂。许多 API 还添加了非标准扩展，使得调试变得困难。此外，许多 API 需要进行审核才能使用，并且 OAuth 安全性也是一个不断变化的目标。为了解决这些问题，Nango 正在开发一种新的方法，该方法提供预构建的 OAuth 流程、安全令牌存储和自动令牌刷新，支持超过 90 个 OAuth API。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[朝着更好的 1 对 1：一个尴尬的宣言]]></title>
        <id>https://tylercipriani.com/blog/2023/04/22/better-1on1s/</id>
        <link href="https://tylercipriani.com/blog/2023/04/22/better-1on1s/"/>
        <updated>2023-05-04T02:47:00.683Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://tylercipriani.com/blog/2023/04/22/better-1on1s/">Towards better 1-on-1s: an awkward manifesto</a></p><p><strong>概要：</strong></p><p>本文介绍了一种有效的 1-on-1s（一对一会议）流程，以帮助工程管理人员和个人贡献者更好地进行每周例会。作者提供了一个简单的 POP（目的、结果、过程）日程安排，包括检查团队成员的状况、更新目标、更新 “自夸文档”、给予反馈等内容。此外，作者还分享了自己的笔记和待办事项系统，以及一些有趣的问题来引导讨论。最后，作者指出成功的 1-on-1s 的关键在于真正关心你的直接报告，才能获得他们的关注和参与。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我想谈谈 WebGPU。]]></title>
        <id>https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu</id>
        <link href="https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu"/>
        <updated>2023-05-04T02:40:46.869Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu">I want to talk about WebGPU</a></p><p><strong>概要：</strong></p><p>WebGPU 是一种新的 WebGL，可以在 Web 浏览器中绘制 3D。它很好用，甚至可能取代 Canvas 成为 Web 浏览器中绘制 2D 的新方式，并取代 Vulkan 和 OpenGL 成为任何编程语言中绘制的标准方式。WebGPU 已经在 Chrome 113 中发布，到年底将会在所有浏览器中普及。对于程序员来说，使用 WebGPU 需要构建一个或多个管道对象，描述 “我运行哪些着色器，以及可以输入什么样的数据” 等信息。此外，WebGPU 提供了 JavaScript、Rust/C++ 等多种语言实现方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Vercel 上的存储功能 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-storage</id>
        <link href="https://vercel.com/blog/vercel-storage"/>
        <updated>2023-05-04T01:58:00.921Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-storage">Introducing storage on Vercel – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel宣布了一套无服务器存储解决方案，包括Vercel KV，一个无服务器的Redis解决方案；Vercel Postgres，一个为前端建立的无服务器SQL数据库；以及Vercel Blob，一个在边缘上传和服务文件的解决方案。这些解决方案旨在使数据库成为Vercel前端云的一流部分，并使开发人员能够管理他们的前端存储需求，而不必担心基础设施。此举是由性能和个性化的需求所驱动的，因为框架变成了服务器优先和边缘优先，世界也从单体架构转向可组合的架构。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宣布 Deno KV。]]></title>
        <id>https://deno.com/blog/kv</id>
        <link href="https://deno.com/blog/kv"/>
        <updated>2023-05-04T01:56:27.393Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/kv">Announcing Deno KV</a></p><p><strong>概要：</strong></p><p>Deno KV 是一款全球复制、强一致性的键值数据库，可在 35 个地区实现低延迟读取。它可以无缝集成到开源 Deno 运行时中，无需任何配置即可在本地或作为托管服务运行。Deno KV 是一个简单但功能强大的一流原语，只暴露了少量方法来存储、检索、删除和枚举数据。它支持原子事务，提供外部一致性和线性化，并可通过 consistency："eventual" 选项放松一致性约束以提高读取操作的响应速度。Deno KV 适用于各种应用场景，如实时协作、用户数据管理和身份验证等。此外，它还提供了一些演示应用程序，如多人井字游戏、像素画板和共享任务列表等，以展示其能力。在未来几个月中，我们将推出更多功能，进一步简化构建和部署应用程序的过程。在 beta 期间，用户可以免费使用最多 1</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自主 GPT-4：从 ChatGPT 到 AutoGPT、AgentGPT、BabyAGI、HuggingGPT 等等。]]></title>
        <id>https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e</id>
        <link href="https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e"/>
        <updated>2023-05-03T10:36:11.064Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pub.towardsai.net/autonomous-gpt-4-from-chatgpt-to-autogpt-agentgpt-babyagi-hugginggpt-and-beyond-9871ceabd69e">Autonomous GPT-4: From ChatGPT to AutoGPT, AgentGPT, BabyAGI, HuggingGPT, and Beyond</a></p><p><strong>概要：</strong></p><p>本文介绍了 ChatGPT 和 LLM 技术的兴起，这些先进的语言模型已经引起了开发者、爱好者和组织的广泛关注。为了更好地整合和构建这些先进模型，出现了像 LangChain 和 LlamaIndex 这样的平台。随着自动化任务和 AI 代理越来越多地利用 GPT-4 的能力，这些创新平台正在重新定义我们与 LLMs 互动的方式。本文还介绍了几个基于 GPT-4 的自主 AI 工具和应用，包括 Auto-GPT、AgentGPT、BabyAGI、HuggingGPT、Web LLM、God Mode 和 CAMEL。这些工具和应用可以分为命令行界面（CLI）和基于浏览器的解决方案两类。这些平台正在推动人工智能领域的突破性创新和进步。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 渲染交互指南]]></title>
        <id>https://ui.dev/why-react-renders</id>
        <link href="https://ui.dev/why-react-renders"/>
        <updated>2023-04-27T04:47:36.154Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://ui.dev/why-react-renders">The Interactive Guide to Rendering in React</a></p><p><strong>概要：</strong></p><p>本文主要介绍了 React 的渲染机制，即 React 只有在状态改变时才会重新渲染组件。当事件处理程序被调用时，如果其中包含 useState 的更新函数，并且新状态与快照中的状态不同，React 将触发重新渲染。此外，本文还介绍了 React 的批处理算法和 StrictMode 组件。最后，作者提醒读者，在实际开发中需要注意组件的纯度和性能问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用 Rust 和 Napi rs 在 NodeJs 中将 CSV 文件处理速度提高五倍]]></title>
        <id>https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs</id>
        <link href="https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs"/>
        <updated>2023-04-27T00:47:13.797Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.alxolr.com/articles/how-to-process-a-csv-file-five-times-faster-in-node-js-with-rust-and-napi-rs">How to process a CSV file five times faster in NodeJs with Rust and Napi rs</a></p><p><strong>概要：</strong></p><p>本文介绍了如何使用 Rust 和 Napi rs 在 NodeJs 中处理 CSV 文件。作者使用了 readline 模块来处理 CSV 文件，并记录了处理时间和吞吐量。然后作者使用了 Rust 编写了相同的代码，并通过 pv 命令进行了基准测试，发现 Rust 版本比 Nodejs 版本快五倍。最后，作者介绍了如何使用 Napi rs 将 Rust 代码编译成动态库，并在 Nodejs 中调用。总之，结合 Rust 和 Nodejs 可以实现更好的性能和效率。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 useReducer 的创造性方式]]></title>
        <id>https://www.code-insights.dev/posts/creative-ways-of-using-usereducer</id>
        <link href="https://www.code-insights.dev/posts/creative-ways-of-using-usereducer"/>
        <updated>2023-04-27T00:36:42.149Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.code-insights.dev/posts/creative-ways-of-using-usereducer">Creative ways of using useReducer</a></p><p><strong>概要：</strong></p><p>本文介绍了 React 中的 useReducer 钩子函数，它可以用于管理复杂状态。通过传递一个 reducer 函数、一个初始值和一个可选的初始化函数，useReducer 返回一个包含当前状态和 dispatch 函数的数组。使用 dispatch 函数更新状态时，它会调用 reducer 函数并返回下一个状态。但是，由于函数式 JavaScript 的宽容性质，useReducer 还可以以不同的方式创造性地使用。文章提供了一些例子，如简单的开关、增量按钮、增强状态和安全状态等，演示了使用 useReducer 管理状态的优势。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年在哪里托管您的 Remix 应用程序？]]></title>
        <id>https://www.jacobparis.com/guides/where-to-host-remix</id>
        <link href="https://www.jacobparis.com/guides/where-to-host-remix"/>
        <updated>2023-04-27T00:36:17.402Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.jacobparis.com/guides/where-to-host-remix">Where to host your Remix app in 2023</a></p><p><strong>概要：</strong></p><p>本文介绍了多种应用托管方式，包括无服务器函数、Netlify、Vercel、Cloudflare Pages、Fastly、AWS Lambda 和长期运行的服务器。对于每种托管方式，文章列出了其优点和缺点，以及支持的功能和限制。需要根据自己的应用需求选择适合的托管方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现 experimental_useFormStatus by acdlite・Pull Request #26722・facebook/react]]></title>
        <id>https://github.com/facebook/react/pull/26722</id>
        <link href="https://github.com/facebook/react/pull/26722"/>
        <updated>2023-04-27T00:32:22.463Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/facebook/react/pull/26722">Implement experimental_useFormStatus by acdlite · Pull Request #26722 · facebook/react</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一个新的 React Hook，可以读取其祖先表单组件的状态，用于实现加载指示器等功能。目前该 Hook 只在实验通道中可用，随着其稳定性的提高，将会发布更多 API 和文档。该 Hook 内部使用 startTransition 和上下文对象实现，但实际实现细节可能会发生变化。由于表单元素不能嵌套，因此实现者不需要跟踪多个嵌套的 “转换提供者”。虽然它使用通用的 Fiber 配置方法进行实现，但它目前仍基于 React DOM 的要求进行一些假设。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[岛屿的温和介绍]]></title>
        <id>https://deno.com/blog/intro-to-islands</id>
        <link href="https://deno.com/blog/intro-to-islands"/>
        <updated>2023-04-27T00:31:14.024Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/intro-to-islands">A Gentle Introduction to Islands</a></p><p><strong>概要：</strong></p><p>本文介绍了一种名为 “Islands” 的解决方案，用于应对那些需要一定交互性但不需要大量 JavaScript 的网站。Islands 是指使用 Preact 组件来实现交互，并在静态渲染的 HTML 页面中进行客户端渲染。这种方法避免了将整个框架打包发送到客户端的问题，同时也使开发人员能够更加有意识地选择何时使用 JavaScript。文章还提到了其他一些解决方案，如 React Server Components 和 Quik 的可恢复性，以及 Astro 和 Marko 等框架中类似的技术。总之，Islands 是一种简单而有效的解决方案，可以帮助开发人员更好地控制网站的交互性和 JavaScript 的使用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我作为新经理所犯的一些错误]]></title>
        <id>https://www.benkuhn.net/newmgr/</id>
        <link href="https://www.benkuhn.net/newmgr/"/>
        <updated>2023-04-25T00:56:17.319Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.benkuhn.net/newmgr/">Some mistakes I made as a new manager</a></p><p><strong>概要：</strong></p><p>这篇文章讲述了作者成为管理者的经历，以及他在这个过程中犯下的错误和解决策略。作者指出，作为一名管理者，最初的困难之一是难以确定自己的工作是否有用。他提供了三种应对策略：与上级领导沟通，寻求反馈，多元化生活体验。此外，作者还分享了其他的经验教训，如管理的重要性、任务相关成熟度、拖延维护、直接询问等。最后，作者总结了成为新管理者的困难所在，并鼓励读者不要害怕犯错，因为这是成长的必经之路。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 装饰器：完整指南]]></title>
        <id>https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/</id>
        <link href="https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/"/>
        <updated>2023-04-25T00:45:02.471Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deadsimplechat.com/blog/typescript-decorators-a-complete-guide/">TypeScript Decorators: A complete guide</a></p><p><strong>概要：</strong></p><p>本文介绍了 TypeScript 的装饰器，装饰器本质上是函数，可以用于给类、方法、属性等应用可重用的行为。不同类型的装饰器包括类装饰器、方法装饰器、属性装饰器、访问器装饰器和参数装饰器。装饰器可以用于实现各种功能，如前 / 后钩子、监视属性更改和方法调用、转换参数、自动序列化和反序列化、依赖注入等。使用装饰器的优点包括跨越关注点、依赖注入、验证和代码组织。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - partykit/partykit：有了朋友，一切都更好。]]></title>
        <id>https://github.com/partykit/partykit</id>
        <link href="https://github.com/partykit/partykit"/>
        <updated>2023-04-25T00:43:43.337Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/partykit/partykit">GitHub - partykit/partykit: Everything's better with friends.</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 partykit 的软件开发工具包，可以用于构建实时协作应用程序。用户可以将其与现有的 Web 应用程序一起使用，也可以从头开始构建新的应用程序。该工具包提供了简单易用的服务器和客户端代码，使用户能够轻松地添加实时协作功能，如协同编辑器、多人游戏等。此外，文章还介绍了 y-partykit 和 party.io 两个相关的库，可以帮助用户更方便地构建协作应用程序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新的断点侧边栏如何帮助您更快地进行调试 - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/en/blog/breakpoint-ux-redesign/</id>
        <link href="https://developer.chrome.com/en/blog/breakpoint-ux-redesign/"/>
        <updated>2023-04-25T00:23:16.053Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/en/blog/breakpoint-ux-redesign/">How the new Breakpoints sidebar helps you debug faster - Chrome Developers</a></p><p><strong>概要：</strong></p><p>Google Chrome 最新版本的调试工具已经更新了断点侧边栏的设计。这个更新旨在提高断点调试的效率，通过提供更好的断点概览、更直观易用的用户工作流程和更可见的断点特性来实现。更新后的断点侧边栏集中于使现有功能更加直观易用，而非添加新功能。更新后的功能包括：暂停异常以调查代码错误、管理断点（展开相关断点组、折叠其他组、单击跳转到代码位置、删除或启用 / 禁用断点）以及使用条件断点和日志点等不太常用的断点特性。如果您有进一步的建议或反馈，请通过 crbug.com 提交。同时，建议使用 Chrome Canary、Dev 或 Beta 版本作为默认开发浏览器，以获得最新的 DevTools 功能。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[“const” 欺骗]]></title>
        <id>https://www.joshwcomeau.com/javascript/the-const-deception/</id>
        <link href="https://www.joshwcomeau.com/javascript/the-const-deception/"/>
        <updated>2023-04-25T00:12:35.864Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshwcomeau.com/javascript/the-const-deception/">The “const” Deception</a></p><p><strong>概要：</strong></p><p>本文介绍了 JavaScript 中的 const 关键字，它用于声明常量。虽然 const 声明的对象是不可重新赋值的，但我们仍然可以修改该对象的属性或元素。文章讲解了变量名作为标签、重新分配标签和修改数据等概念，并介绍了原始数据类型的特点。最后，作者推荐了一些深入学习 JavaScript 的资源。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年，Rust 能否击败 JavaScript？]]></title>
        <id>https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023</id>
        <link href="https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023"/>
        <updated>2023-04-24T08:43:58.611Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023">Can Rust Beat JavaScript in 2023?</a></p><p><strong>概要：</strong></p><p>本文介绍了 Rust 作为 Web 开发语言的优势。尽管在过去，一些人认为使用 Rust 前端开发（通过 WASM）比 JavaScript 慢或者不够成熟，但是现在已经不再是问题。实际测试表明，Rust WASM 框架如 Leptos 和 Dioxus 在性能上超越了大多数 JavaScript 框架，同时 Rust 也有着出色的后端性能，在 TechEmpower 的排名中占据了五个前十名的位置。此外，Rust 还具有良好的开发体验和错误处理机制，并且拥有完善的生态系统来支持数据库、Redis、Stripe 支付等服务。最后，文章介绍了 Shuttle 作为部署 Rust 应用的工具。总之，Rust 是一个非常值得使用的 Web 开发语言，可以提供更好的性能、更低的内存占用和更好的服务稳定性。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[职业建议：辞职时提前通知很重要]]></title>
        <id>https://davidlaprade.github.io/give-a-lot-of-notice</id>
        <link href="https://davidlaprade.github.io/give-a-lot-of-notice"/>
        <updated>2023-04-24T01:03:24.977Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://davidlaprade.github.io/give-a-lot-of-notice">Career Advice No One Gave Me: Give a Lot of Notice When You Quit</a></p><p><strong>概要：</strong></p><p>在辞职时，通常给予两周的提前通知是黄金标准。但是，给予更长时间的通知实际上有很多好处。这些好处包括：只做自己最喜欢的工作部分、消除所有工作压力、获得相同的薪水、延长福利期限、休假时间没有使用、股票归属权增加、获得奖金、留下积极的印象、受到感谢和赞赏等。如果你是一名能干的软件工程师，并且在公司中地位良好，那么给予超过两周的通知通常对所有人都是有利的。此外，给予更长时间的通知还可以使公司更顺利地进行转型，减少风险等。

为什么公司会同意这样做呢？通常情况下，需要签署延长通知期的人是工程师的经理，可能还包括人力资源部门。但是，如果你的</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[是时候学习 oklch 颜色了。]]></title>
        <id>https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/</id>
        <link href="https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/"/>
        <updated>2023-04-24T01:01:10.314Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://keithjgrant.com/posts/2023/04/its-time-to-learn-oklch-color/">It's time to learn oklch color</a></p><p><strong>概要：</strong></p><p>本文介绍了最新的 CSS 颜色标记法，包括 hwb ()、lab ()、lch ()、oklab ()、oklch () 和 color ()。文章推荐学习 oklch () 标记法，因为它基于人眼感知而不是技术限制，可以定义任何颜色，并且支持更广泛的色域。此外，文章还提到了使用 oklch () 时需要注意的一些问题，如 chroma 值的范围和 hue 值的变化等。最后，文章推荐了一个在线颜色选择器 oklch.com，方便调试和转换其他颜色格式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[批判性思维是软件工程师最重要的技能吗？]]></title>
        <id>https://blog.pragmaticengineer.com/critical-thinking/</id>
        <link href="https://blog.pragmaticengineer.com/critical-thinking/"/>
        <updated>2023-04-24T01:00:31.080Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.pragmaticengineer.com/critical-thinking/">Is Critical Thinking the Most Important Skill for Software Engineers?</a></p><p><strong>概要：</strong></p><p>这篇文章谈到了两个现象：技术术语的使用和 “思想领袖” 在社交媒体上的崛起，以及这些现象对批判性思维的影响。作者认为，过度使用技术术语可能掩盖了人们对某一概念的真正理解，而 “思想领袖” 的观点也不应该被轻易地接受，需要进行深入的研究和验证。作者建议人们提高批判性思维能力，包括理解技术术语、验证信息、问 “为什么” 和 “如何”，并避免跟风。最后，作者强调批判性思维将在未来变得越来越重要，因为随着人工智能工具的普及，我们需要更多的人来质疑和思考。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么你应该在社区大学教书]]></title>
        <id>https://timozander.de/blog/why-you-should-teach/</id>
        <link href="https://timozander.de/blog/why-you-should-teach/"/>
        <updated>2023-04-24T00:36:52.865Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://timozander.de/blog/why-you-should-teach/">Why you should teach at a Community College</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了作者作为软件开发者教授 IT 课程的经历，并总结了教学对于软件开发者的好处。首先，教学可以帮助开发者更好地了解普通用户的需求和使用习惯，从而改善软件的用户体验；其次，教学可以提高开发者的语言表达能力，让他们更好地将复杂概念简单易懂地传达给学生；最后，教学本身也是一种学习，通过教学可以不断提升自己的技能和知识水平。作者建议开发者在编写指导文档时要详细、清晰地说明每一个步骤，同时要注意避免使用过多的技术术语和缩略语。此外，作者还鼓励有志于成为教师的人士加入到 STEM 教育中来，为缓解教师短缺问题做出贡献。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么在 React 中你不需要信号（Signals）]]></title>
        <id>https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/</id>
        <link href="https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/"/>
        <updated>2023-04-24T00:36:07.525Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://blog.axlight.com/posts/why-you-dont-need-signals-in-react/">Why You Don't Need Signals in React</a></p><p><strong>概要：</strong></p><p>本文介绍了信号在 React 中的两个方面：反应式原语和绕过 diffing。反应式是 React 的一个关键特性，可以通过 useState 创建反应式原语来定义状态，并触发重新渲染。为了简化全局状态的定义和使用，第三方库 Jotai 可以很有用。Jotai 提供了 atoms 来定义全局状态，这些 atoms 可以表示状态的定义，也可以定义依赖于其他 atoms 的派生状态。与 useState 不同，useAtom 不是局部状态，可以在另一个组件中使用来共享 atom 状态。另一个重要的特性是绕过 diffing。React 通过比较 UI 的先前和当前表示来更新 DOM，以确定已更改的内容并仅更新 DOM 的那些部分，从而实现更好的性能和响应性。然而，绕过 diffing 可能会导致 UI 不一致，并使应用程序更难理解。因此，在决定绕过 diffing 之前，需要全面评估性能收益并权衡潜在风险。总之，Jotai 提供了一种更简单</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[说不要 "闪烁" 的 UI：使用 useLayoutEffect，绘画和浏览器故事]]></title>
        <id>https://www.developerway.com/posts/no-more-flickering-ui</id>
        <link href="https://www.developerway.com/posts/no-more-flickering-ui"/>
        <updated>2023-04-24T00:34:43.692Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.developerway.com/posts/no-more-flickering-ui">Say no to "flickering" UI: useLayoutEffect, painting and browsers story</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中如何根据 DOM 测量更改元素的基础知识。文章首先通过一个响应式导航组件的例子，讲解了如何使用 useEffect 来计算容器大小和每个元素的尺寸，并且根据这些信息来调整元素的数量。然而，这种方法会导致初始渲染时出现闪烁问题。为了解决这个问题，文章介绍了 useLayoutEffect 的用法，并解释了浏览器渲染、绘制和事件循环等相关概念。最后，文章还讨论了在 Next.js 等服务器端渲染框架中使用 useLayoutEffect 的问题。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🔥 掌握 ReactJS 优化 - ITNEXT]]></title>
        <id>https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f</id>
        <link href="https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f"/>
        <updated>2023-04-24T00:19:26.031Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://itnext.io/mastering-reactjs-optimization-d75b0af09a2f">🔥 Mastering ReactJS optimization - ITNEXT</a></p><p><strong>概要：</strong></p><p>本文介绍了一些优化 React 应用程序的关键技术。首先，文章列举了常见的性能瓶颈，如大型包大小、慢渲染和网络请求不优化等。接着，文章介绍了一些优化策略，包括代码分割、懒加载、记忆化、分析器和服务器端渲染。通过掌握这些技术，可以创建快速响应、用户体验良好的 React 应用程序。其中，代码分割是将代码拆分成小块，在需要时按需加载，从而减少初始加载时间的强有力的优化技术；懒加载则是仅在需要时加载模块，而不是预加载所有内容，同样可以提高应用程序的性能。此外，文章还介绍了记忆化、分析器和服务器端渲染等其他优化技术。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们如何让 Vite 4.3 更快]]></title>
        <id>https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html</id>
        <link href="https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html"/>
        <updated>2023-04-22T02:32:50.851Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html">How we made Vite 4.3 faaaaster</a></p><p><strong>概要：</strong></p><p>Vite 4.3 是一个快速的 JavaScript 构建工具，它在性能方面进行了改进。这篇文章介绍了 Vite 4.3 是如何通过优化解析策略、使用异步函数、并行处理和 JavaScript 优化等方式来提高性能的。此外，该文章还介绍了一些与 Vite 4.3 相关的基准测试生态系统和插件。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 v5.80.0・webpack/webpack]]></title>
        <id>https://github.com/webpack/webpack/releases/tag/v5.80.0</id>
        <link href="https://github.com/webpack/webpack/releases/tag/v5.80.0"/>
        <updated>2023-04-21T02:20:51.852Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/webpack/webpack/releases/tag/v5.80.0">Release v5.80.0 · webpack/webpack</a></p><p><strong>概要：</strong></p><p>本文介绍了 Webpack v5.80.0 的更新内容，包括新增功能、Bug 修复、测试和贡献者体验、开发者体验以及依赖项和维护等方面。新增功能包括支持在 import.meta 中使用解构赋值、支持带有 AwaitExpression 的解构赋值的树摇、引入 errorsSpace 和 warningsSpace 以获得更可读的跟踪信息等。Bug 修复主要涉及 CSS 相关问题、语法错误、模块 ID 分配等。此外，还对测试用例进行了完善，优化了开发者体验，并更新了一些依赖项。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deno vs. Node：没有人准备好迎接这个变化 | .cult by Honeypot]]></title>
        <id>https://cult.honeypot.io/reads/deno-vs-node-main-differences/</id>
        <link href="https://cult.honeypot.io/reads/deno-vs-node-main-differences/"/>
        <updated>2023-04-21T00:30:49.371Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://cult.honeypot.io/reads/deno-vs-node-main-differences/">Deno vs. Node: No One is Ready for the Move | .cult by Honeypot</a></p><p><strong>概要：</strong></p><p>本文介绍了 Node.js 和 Deno 两个 JavaScript 运行环境的比较。Node.js 是一个流行的服务器端、开源、跨平台的 JavaScript 运行环境，自 2009 年以来一直占据着 Web 开发世界的主导地位。它专注于事件驱动的 HTTP 服务器，并使用单线程的事件循环处理请求。与大多数竞争对手不同的是，Node.js 基于回调函数的扩展机制可以在最小内存使用下处理更多的请求。相比之下，Deno 在设计上有所改进，提供了更安全的框架和现代特性，由 Node.js 的创始人 Ryan Dahl 推出。然而，尽管 Deno 解决了 Node.js 的一些设计缺陷，但采用 Deno 的速度非常缓慢，大多数开发人员仍然满意于 Node.js。本文将探讨这种现象背后的原因，并对 Node.js 和 Deno 进行比较，从第三方包管理、API、安全性和 TypeScript 支持等方面进行分析。</p>]]></content>
    </entry>
</feed>
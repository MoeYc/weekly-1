<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>articles@mdhweekly.com</id>
    <title>MDH Weekly · 深度好文</title>
    <updated>2023-03-23T00:58:38.184Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mdhweekly.com"/>
    <subtitle>深度好文 from MDH Weekly</subtitle>
    <rights>sorrycc@gmail.com</rights>
    <entry>
        <title type="html"><![CDATA[您可能不需要的钩子]]></title>
        <id>https://reacttraining.com/blog/hooks-you-probably-dont-need</id>
        <link href="https://reacttraining.com/blog/hooks-you-probably-dont-need"/>
        <updated>2023-03-23T00:45:31.085Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://reacttraining.com/blog/hooks-you-probably-dont-need">Hooks You Probably Don't Need</a></p><p><strong>概要：</strong></p><p>本文介绍了 React Hooks 中一些不太常用的 Hook，包括 useDebugValue ()、useInsertionEffect ()、useImperativeHandle ()、useSyncExternalStore ()、useDeferredValue ()、useEffect () 和 useLayoutEffect ()。作者将这些 Hook 按照使用频率分为三类：不太可能使用的（红色）、偶尔会使用的（橙色）和根据具体情况而定的（绿色）。其中，useDebugValue () 用于在 DevTools 中为自定义 Hook 创建标签以进行调试；useInsertionEffect () 主要面向 CSS-in-JS 库开发者；useImperativeHandle () 用于限制或自定义向父组件暴露的 DOM 元素 API；useSyncExternalStore () 适用于第三方状态管理库或公开可变值和事件的浏览器 API；useDeferredValue () 用于显示过时内容并在加载新内容时延迟重新渲染 UI；useEffect () 用于处理渲染阶段的副作用，如数据获取；useLayoutEffect () 则用于在 UI 渲染前运行同步副作用。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无限混音 - Vercel]]></title>
        <id>https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support</id>
        <link href="https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support"/>
        <updated>2023-03-23T00:39:59.131Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support">Remix without Limits – Vercel</a></p><p><strong>概要：</strong></p><p>Vercel has announced an advanced integration with Remix, a server-rendered React framework. The integration allows developers to stream content dynamically using Node.js and Edge runtimes, build serverless APIs with Remix and a route loader, use powerful cache headers like stale-while-revalidate for advanced caching, and run data mutations inside Serverless or Edge Functions. The integration also supports both Node.js and Web/Edge-oriented runtimes on a per-route basis, enabling developers to take advantage of the best parts of both. Additionally, Vercel's Edge Network Cache supports caching loader responses and newer caching headers like stale-if-error.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实验室：我们正在进行的工作 ——2023 年 3 月 ——React]]></title>
        <id>https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023</id>
        <link href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023"/>
        <updated>2023-03-23T00:04:10.043Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023">React Labs: What We've Been Working On – March 2023 – React</a></p><p><strong>概要：</strong></p><p>React Labs 发布了最新的研究进展，包括 React Server Components、Asset Loading、Document Metadata、React Optimizing Compiler、Offscreen Rendering 和 Transition Tracing 等。其中，React Server Components 是由 React 团队设计的一种新的应用架构，它结合了服务器中心多页面应用程序的简单 “请求 / 响应” 模型和客户端中心单页面应用程序的无缝交互性，同时提供了一种新的组件类型 ——Server Components，它们可以在构建期间运行，也可以在服务器上运行，让您无需构建 API 即可访问数据层。另外，React Labs 还在开发 Suspense、Transition Tracing 等功能，以提高 React 的性能和用户体验。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[那么，您已经安装了 `fzf`。现在该怎么办？]]></title>
        <id>https://andrew-quinn.me/fzf/</id>
        <link href="https://andrew-quinn.me/fzf/"/>
        <updated>2023-03-22T15:41:43.724Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://andrew-quinn.me/fzf/">So you've installed `fzf`. Now what?</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 fzf 的工具，它是一个命令行模糊搜索工具，可以极大地提高 Linux 和 Windows 终端用户的效率。作者提到，fzf 的快捷键能够替代基础版本的 Ctrl+R，并且还有一些其他功能，例如 Alt+C 可以快速跳转目录，vi $(fzf) 可以模糊查找文件并打开编辑器等。此外，作者还介绍了另一个工具 rg，它是一个快速的递归 grep 工具，可以与 fzf 结合使用来进行模糊搜索文件内容。总之，fzf 和 rg 都是非常实用的命令行工具，值得一试。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Copilot X：AI 动力的开发者体验 | GitHub 博客]]></title>
        <id>https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/</id>
        <link href="https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/"/>
        <updated>2023-03-22T14:38:23.977Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/">GitHub Copilot X: The AI-powered developer experience | The GitHub Blog</a></p><p><strong>概要：</strong></p><p>GitHub Copilot X 是 GitHub 的新一代 AI 辅助开发工具，它将 AI 引入整个开发生命周期中。除了自动完成注释和代码外，Copilot X 还支持聊天和语音交互，并在 pull requests、命令行和文档中提供 AI 支持。Copilot X 基于 OpenAI 的 GPT-4 模型，可以为开发人员生成单元测试、修复错误等。此外，Copilot X 还支持针对文档的 ChatGPT 接口，让开发人员能够快速获取关于 React、Azure Docs 和 MDN 等文档的答案。GitHub 希望通过 Copilot X 改变开发者的工作方式，提高其生产力和创造力。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 2023 年开始一个 React 项目]]></title>
        <id>https://www.robinwieruch.de/react-starter/</id>
        <link href="https://www.robinwieruch.de/react-starter/"/>
        <updated>2023-03-22T04:52:06.786Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.robinwieruch.de/react-starter/">How to start a React Project in 2023</a></p><p><strong>概要：</strong></p><p>本文介绍了几种新 React 项目的起始套件，包括 React with Vite、React with Next、React with Astro 等。作者对每种套件的优缺点、开发者所需技能水平以及针对 React 开发者提供的特性进行了分析，并给出了不同需求的三种解决方案。最后，文章总结了一些关于 React 起始项目的思考和建议。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务器首选框架 - HackMD]]></title>
        <id>https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di</id>
        <link href="https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di"/>
        <updated>2023-03-22T04:34:33.396Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://hackmd.io/@0u1u3zEAQAO0iYWVAStEvw/rJFCoM4Di">Server First Framework - HackMD</a></p><p><strong>概要：</strong></p><p>该文章提出了一个名为 “Server First Framework” 的框架概念，预计将于 2023 年推出。作者认为，虽然过去十年的单页面应用程序（SPA）教会了我们很多东西，但我们现在携带了太多负担。设计面向服务器的框架时，要避免使用过多的同构倾向。

该框架的初始页面呈现与 Islands 框架非常相似。所有组件都是经过服务器渲染并发送到浏览器的。客户端组件道具被序列化，并启动任何资源内部的客户端组件。客户端组件被收集并且被水合（如果流式传输可用）。对于后续的导航，路由器将使用下一个 URL（包括当前 URL）请求服务器。服务器能够处理它以确定需要呈现哪些路由部分。同时，客户端请求下一个 URL 所需的所有 Islands 以加载代码。服务器仅呈现新路由部分，跳过呈现客户端组件，但仍然序列化道具。客户端接收响应，并能够使用 HTML 差异交换路由输出。在核心部分，变异遵循 MPA 的模式。您发送数据，服务器响应表示该更改的新标记。您可以将其视为表单提交。该请求响应下一页，因此处理程序可能会使用重定向 / 无效返回语法，即使它们都作为同一服务器响应的一部分进行处理。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编写你自己的响应式信号库]]></title>
        <id>https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/</id>
        <link href="https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/"/>
        <updated>2023-03-21T04:35:53.580Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/">Writing Your Own Reactive Signal Library</a></p><p><strong>概要：</strong></p><p>近来，前端领域出现了对细粒度反应性的新发现，这是一种通过使用三个主要原语：信号、效果和备忘录来构建反应式用户界面的风格。最近，我们看到像 Angular、Preact 和 Qwik 这样的框架在其现有框架中添加了信号。当然，SolidJS 是我选择的框架，创建者 Ryan Carniato 也引领了前端框架中信号的流行趋势。

什么是信号？

“信号” 这个名字并不特别描述性，所以它可能会让人感到有点困惑，不知道它提供了什么好处，以及它与 RxJS Observables 之类的东西有何不同。SolidJS 提供了一个很好的定义：

信号是事件发射器，它们保存订阅列表。每当它们的值发生变化时，它们就会通知其订阅者。

- SolidJS 文档

如果这不完全有意义，不用担心 —— 我们将通过编写自己的信号来学习！

为什么要创建自己的信号？

如果所有这些库都已经提供了信号原语，为什么我们要编写自己的信号呢？实际上，主要是作为一种学习体验！我不一定建议使用我们编写的内容来代替 Solid 等框架，因为它包含了针对不同边缘情况的更高级优化。相反，这种做法将帮助您更好地理解 Solid 和反应性的工作方式。

基础知识

对于我们的基本反应系统，我们将创建两个原语：createSignal 和 createEffect。备忘录（又称 createMemo）是反应性的第</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SPA 视图过渡在 Chrome 111 中实现 - Chrome 开发者]]></title>
        <id>https://developer.chrome.com/blog/spa-view-transitions-land/</id>
        <link href="https://developer.chrome.com/blog/spa-view-transitions-land/"/>
        <updated>2023-03-21T04:35:25.858Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://developer.chrome.com/blog/spa-view-transitions-land/">SPA view transitions land in Chrome 111 - Chrome Developers</a></p><p><strong>概要：</strong></p><p>View Transition API 是一种可以在单个步骤中更新 DOM 的 API，同时生成两种状态之间的动画过渡。该功能目前只在 Chrome 浏览器上可用，但可以作为逐步增强使用。View Transitions API 设计成可以跨同源文档工作，下一步将优化它的性能和扩展性。该 API 还支持多种扩展，包括文档之间的转换、组合器驱动的动画、范围转换、嵌套转换组、转换类别等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Dagster、dbt 和 BigQuery 追踪假的 GitHub Star 黑市 | Dagster 博客]]></title>
        <id>https://dagster.io/blog/fake-stars</id>
        <link href="https://dagster.io/blog/fake-stars"/>
        <updated>2023-03-21T04:34:12.852Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://dagster.io/blog/fake-stars">Tracking the Fake GitHub Star Black Market with Dagster, dbt and BigQuery | Dagster Blog</a></p><p><strong>概要：</strong></p><p>GitHub stars 是 GitHub 上社交证明的主要指标之一。然而，虚假的 stars 也会影响高风险决策，如企业使用哪些项目、哪些创业公司获得资金以及哪些公司有才华的专业人士加入。Dagster 团队发现了一些新的开源项目突然在几天内获得数百个星星，这让他们产生了怀疑。因此，他们购买了一些虚假的 stars，并通过 GitHub REST API 和 GitHub Archive 数据库运行了一些 repos 测试。他们采用了两种方法来识别虚假 stars：识别明显的伪造和识别复杂的伪造。最终，他们发现了一个简单的 “低活跃度” 启发式，可以检测到许多（但不是全部）涉嫌伪造的账户。另外，他们使用了无监督聚类技术来识别更复杂的虚假账户。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端开发的终结]]></title>
        <id>https://www.joshwcomeau.com/blog/the-end-of-frontend-development/</id>
        <link href="https://www.joshwcomeau.com/blog/the-end-of-frontend-development/"/>
        <updated>2023-03-21T04:25:39.556Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.joshwcomeau.com/blog/the-end-of-frontend-development/">The End of Front-End Development</a></p><p><strong>概要：</strong></p><p>很多初入行的开发者越来越担心人工智能的崛起，他们看到了像 GPT-4 这样的工具越来越令人印象深刻的演示，担心等到他们精通 HTML/CSS/JS 时，就没有任何工作机会了。然而，作者并不认为 Web 开发人员的工作将会消失。虽然 AI 会改变一些事情，但并不是人们所说的那种可怕的方式。作者认为最有可能的情况是，像 GPT-4 这样的工具将被整合到开发工具中，用于增强熟练开发人员的能力。而且，如果每个开发人员都变得更有效率，那么需求肯定会超过供应，因此总的开发人员数量可能会增加。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你需要知道平衡！CSS 平衡！| pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/you-need-to-know-the-balance-css-balance/</id>
        <link href="https://pawelgrzybek.com/you-need-to-know-the-balance-css-balance/"/>
        <updated>2023-03-20T13:06:23.086Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/you-need-to-know-the-balance-css-balance/">You need to know the balance! CSS balance! | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>本文介绍了 CSS Text Module Level 4 的一项新功能 ——text-wrap: balance。该功能可以在多行文本中更好地分配剩余空间，避免出现排版上的问题。然而，由于其算法需要大量资源，目前仅限于文本长度较短的情况下使用。规范草案将此限制设置为 10 行，但当前的 Google Chrome Canary 实现将此功能限制为 4 行。未来，可能不再需要 React Wrap Balancer 等工具。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么我们将 package.json 支持添加到 Deno 中]]></title>
        <id>https://deno.com/blog/package-json-support</id>
        <link href="https://deno.com/blog/package-json-support"/>
        <updated>2023-03-20T04:08:58.299Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://deno.com/blog/package-json-support">Why We Added package.json Support to Deno</a></p><p><strong>概要：</strong></p><p>Deno 最新版本的发布引入了一个重大变化：通过支持 package.json，提供了增强的 Node 和 NPM 兼容性。这一更新引发了关于我们的优先级是否发生了变化的问题，因为 Deno 长期以来一直被视为与 Node 不同的道路开拓者。事实上，在第一个 Deno 演示中，明确提到了 package.json 是一个遗憾。因此，许多用户对此发展感到惊讶。本文将解决这些问题，分享我们不断发展的思想，并概述我们的未来目标。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 useImperativeHandle 进行细调 refs]]></title>
        <id>https://prateeksurana.me/blog/fine-tuning-refs-with-useimperativehandle/</id>
        <link href="https://prateeksurana.me/blog/fine-tuning-refs-with-useimperativehandle/"/>
        <updated>2023-03-20T04:07:57.935Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://prateeksurana.me/blog/fine-tuning-refs-with-useimperativehandle/">Fine-tuning refs with useImperativeHandle</a></p><p><strong>概要：</strong></p><p>本文介绍了在 React 中使用 refs 和 useImperativeHandle 的方法。Refs 是一种用于在组件之间传递数据的机制，可以让你访问 DOM 节点并使用原生 JavaScript DOM API 对其进行操作。useImperativeHandle 允许你自定义要公开的 ref 处理程序，以便只公开子组件的特定方法。然而，需要注意的是，在 React 中，最好不要使用 refs 来实现可以通过 props 实现的命令式行为，因为这违反了 React 的核心原则。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重复自己，做更多的事情，重新书写一切。]]></title>
        <id>https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and</id>
        <link href="https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and"/>
        <updated>2023-03-19T14:25:34.198Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and">Repeat yourself, do more than one thing, and rewrite everything</a></p><p><strong>概要：</strong></p><p>编程中的常见建议 “不要重复自己”（DRY）可能会导致更多问题，而不是解决问题。过于严格地遵循这个原则可能会导致程序员创建一个具有四个布尔标志和一系列行为矩阵的函数，并在更改代码时需要小心地进行导航。将事物分成简单的单元可能会导致笨拙的组合和协调交叉变化的困难。避免重写意味着它们通常被推迟到没有成功的机会。但是，有时候遵循这个建议的最佳方法是做相反的事情：采用特性开关并不断重写代码，将事物汇集在一起以便更容易管理它们之间的协调，并重复自己以避免在一个函数中实现所有内容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不要使用过时的机器人]]></title>
        <id>https://fvsch.com/stale-bots</id>
        <link href="https://fvsch.com/stale-bots"/>
        <updated>2023-03-19T14:24:50.555Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://fvsch.com/stale-bots">Don’t use stale bots</a></p><p><strong>概要：</strong></p><p>本文讨论了软件项目中的 “过时机器人” 问题。过时机器人是指在一段时间内没有活动的情况下，自动将问题标记为 “已关闭” 的自动化流程。使用过时机器人会导致用户体验变差，因为它们可能会关闭具有很好复现步骤、截图和评论的问题，这会让用户觉得他们的努力不被重视。此外，过时机器人也会导致重复问题增加，因为关闭的问题不会出现在搜索结果中。文章建议替代过时机器人的方法包括：接受大量开放问题、设置问题筛选流程、制定项目管理计划等。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本地 CSS 嵌套已经到达 | pawelgrzybek.com]]></title>
        <id>https://pawelgrzybek.com/native-css-nesting-landed/</id>
        <link href="https://pawelgrzybek.com/native-css-nesting-landed/"/>
        <updated>2023-03-19T13:45:47.967Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://pawelgrzybek.com/native-css-nesting-landed/">Native CSS nesting landed | pawelgrzybek.com</a></p><p><strong>概要：</strong></p><p>本文介绍了原生 CSS 嵌套的语法和用法，并与 Sass 的嵌套规则进行了比较。作者表示，原生 CSS 嵌套的语法应该对于熟悉 Sass 的人来说很容易理解。此外，文章还提到，CSS 嵌套是 CSS Nesting 规范的第一个版本，随着规范的演进，其功能和语法可能会发生变化。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - xenova/transformers.js：在您的浏览器中运行🤗变形金刚！]]></title>
        <id>https://github.com/xenova/transformers.js</id>
        <link href="https://github.com/xenova/transformers.js"/>
        <updated>2023-03-19T09:17:05.588Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/xenova/transformers.js">GitHub - xenova/transformers.js: Run 🤗 Transformers in your browser!</a></p><p><strong>概要：</strong></p><p>Transformers.js 是一个可以在浏览器中运行的🤗 Transformers 库，支持 BERT、ALBERT、DistilBERT、T5、T5v1.1、FLAN-T5、GPT2、BART、CodeGen、Whisper、CLIP、Vision Transformer 和 VisionEncoderDecoder 等模型，可用于各种任务，包括遮蔽语言建模、文本分类、文本到文本生成、翻译、摘要、问答、文本生成、自动语音识别、图像分类、零样本图像分类和图像到文本。用户可以通过 https://xenova.github.io/transformers.js/ 体验 demo。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 react.dev]]></title>
        <id>https://react.dev/blog/2023/03/16/introducing-react-dev</id>
        <link href="https://react.dev/blog/2023/03/16/introducing-react-dev"/>
        <updated>2023-03-19T08:44:54.669Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://react.dev/blog/2023/03/16/introducing-react-dev">Introducing react.dev</a></p><p><strong>概要：</strong></p><p>React 官方文档网站已经更新，现在的网址是 react.dev。新网站教授使用函数组件和 Hooks 的现代 React，并包括了图表、插图、挑战和 600 多个交互式示例。旧版 React 文档网站已移至 legacy.reactjs.org。新网站分为 “学习 React” 和 “API 参考” 两个主要部分，前者是一个自定进度的课程，后者提供每个 React API 的详细信息和用法示例。新网站还添加了很多沙盒，让用户可以快速玩转 React API、探索想法并检查理解。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - anc95/ChatGPT-CodeReview: 🐥 由 ChatGPT 驱动的代码审查机器人]]></title>
        <id>https://github.com/anc95/ChatGPT-CodeReview</id>
        <link href="https://github.com/anc95/ChatGPT-CodeReview"/>
        <updated>2023-03-19T08:33:11.569Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/anc95/ChatGPT-CodeReview">GitHub - anc95/ChatGPT-CodeReview: 🐥 A code review bot powered by ChatGPT</a></p><p><strong>概要：</strong></p><p>本文介绍了一个名为 CodeReview BOT 的代码审查机器人，它由 ChatGPT 驱动。该机器人可以在创建新的 Pull 请求时自动进行代码审查，并在 PR 时间轴 / 文件更改部分显示审查信息。此外，当您更新拉取请求时，cr 机器人将重新审查更改的文件。使用方法包括安装、配置和使用，同时提供了使用 Github Actions 和自托管两种方式。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[未来保障您的混音应用程序]]></title>
        <id>https://remix.run/blog/future-flags</id>
        <link href="https://remix.run/blog/future-flags"/>
        <updated>2023-03-19T08:02:31.022Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://remix.run/blog/future-flags">Future Proofing Your Remix App</a></p><p><strong>概要：</strong></p><p>Remix, a web development framework, has introduced "Future Flags" to make major version upgrades smoother for users. Future Flags are feature flags for future features that allow developers to opt into breaking changes for the next version individually as they are released in the current version. This means that developers can adopt features incrementally and work out any kinks incrementally before releasing v2. Eventually, deprecation warnings will be added to the v1 releases to nudge users to the new behaviour. Then in v2, the old v1 approach is removed, along with the deprecations and flags, making the flagged behaviour the new default in v2.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 “安全 npm”，一个 Socket npm 包装器 - Socket]]></title>
        <id>https://socket.dev/blog/introducing-safe-npm</id>
        <link href="https://socket.dev/blog/introducing-safe-npm"/>
        <updated>2023-03-19T07:42:04.069Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://socket.dev/blog/introducing-safe-npm">Introducing "safe npm", a Socket npm Wrapper - Socket</a></p><p><strong>概要：</strong></p><p>Socket 推出了一款名为 “safe npm” 的 CLI 工具，用于保护开发人员在使用 npm install 时免受恶意软件、拼写错误、安装脚本、抗议软件和遥测等方面的影响。该工具透明地包装了 npm 命令，并在安装过程中保护开发人员免受恶意软件、拼写错误、安装脚本、抗议软件、遥测等 11 种问题的影响。当开发人员尝试安装恶意或风险包时，Socket 会暂停安装并告知开发人员相关风险。开发人员可以选择停止安装并保护其计算机，也可以继续并接受风险。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub - gajus/turbowatch：Node.js 的极速文件变更检测器和任务编排工具。]]></title>
        <id>https://github.com/gajus/turbowatch/</id>
        <link href="https://github.com/gajus/turbowatch/"/>
        <updated>2023-03-19T07:34:09.828Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/gajus/turbowatch/">GitHub - gajus/turbowatch: Extremely fast file change detector and task orchestrator for Node.js.</a></p><p><strong>概要：</strong></p><p>Turbowatch 是一个用于 Node.js 的极快文件更改检测器和任务编排器。它可用于自动化响应文件更改的任何操作，例如运行（并自动重新启动）长时间运行的进程（如您的 Node.js 应用程序）或构建资产（如 Docker 镜像）。Turbowatch 提供了单个抽象来执行所有文件观察操作，并允许链接任意操作。它还支持日志记录、重试、防抖动、中断工作流、并发工作流等功能。Turbowatch 旨在为具有数十个或数百个相互依赖的构建步骤的单体库或其他复杂工作空间提供更多控制。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JulesBlom.com - React API 地图]]></title>
        <id>https://julesblom.com/writing/map-of-react-api</id>
        <link href="https://julesblom.com/writing/map-of-react-api"/>
        <updated>2023-03-18T10:14:09.488Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://julesblom.com/writing/map-of-react-api">JulesBlom.com - Map of React API</a></p><p><strong>概要：</strong></p><p>这篇文章介绍了一种学习 React API 的方法，即通过将其组织成一个空间地图来帮助理解。作者将 React 的不同部分联系在一起，形成了一个可供探索的结构，并在 “推荐阅读” 部分中添加了一些经过筛选的优质博客文章链接，以便更好地理解 React API。此外，作者还提出了一些未实现的想法，例如将 JSX 语法扩展包括在地图中，以及将 React DevTools、eslint-plugin-react-hooks 和 eslint-plugin-react 等工具添加到地图中。最后，作者感谢所有为 React 文档做出贡献的人和所有撰写收集的文章的作者。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[介绍 Warp AI]]></title>
        <id>https://www.warp.dev/blog/introducing-warp-ai</id>
        <link href="https://www.warp.dev/blog/introducing-warp-ai"/>
        <updated>2023-03-17T02:43:41.376Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.warp.dev/blog/introducing-warp-ai">Introducing Warp AI</a></p><p><strong>概要：</strong></p><p>Warp AI 是一款内置于终端的人工智能，旨在帮助开发人员更高效地工作。用户可以通过向 Warp AI 提问来掌握终端的使用方法，包括解释错误、建议修复方案、编写脚本等。Warp AI 与终端输入和输出的交互方式是其最大优势，它可以将 AI 生成的命令直接运行，而无需复制 / 粘贴或切换上下文。此外，Warp AI 还具有隐私和安全保护措施，只有用户明确输入的内容才会离开本地计算机。目前，Warp AI 已经推出免费试用版，未来将成为付费计划的一部分。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[发布 v6.9.0・remix-run/react-router]]></title>
        <id>https://github.com/remix-run/react-router/releases/tag/react-router%406.9.0</id>
        <link href="https://github.com/remix-run/react-router/releases/tag/react-router%406.9.0"/>
        <updated>2023-03-16T07:16:32.246Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://github.com/remix-run/react-router/releases/tag/react-router%406.9.0">Release v6.9.0 · remix-run/react-router</a></p><p><strong>概要：</strong></p><p>React Router 发布了 6.9.0 版本，支持使用 React 组件定义路由元素和错误元素字段。此外，还引入了 Lazy Route Modules，以保持应用程序包的小巧和支持代码分割路由。此功能通过 lazy () 路由属性实现，是一个异步函数，解析路由定义的非匹配部分。该版本还修复了一些问题，并改进了上下文提供程序的记忆化，以避免不必要的重新渲染。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Execa 7 的无 Shell 脚本 | ITNEXT]]></title>
        <id>https://itnext.io/shell-free-scripts-with-execa-7-885fb3b42f83</id>
        <link href="https://itnext.io/shell-free-scripts-with-execa-7-885fb3b42f83"/>
        <updated>2023-03-16T06:20:44.073Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://itnext.io/shell-free-scripts-with-execa-7-885fb3b42f83">Shell-free scripts with Execa 7 | ITNEXT</a></p><p><strong>概要：</strong></p><p>Google 近期推出了一个名为 zx 的项目，将 shell 脚本和 JavaScript 语言结合起来。这个项目利用 7 年历史的 Node 模块 Execa，使命令和进程易于执行，并提供了类似于 zx 的模式，但采用更简单的纯 JavaScript 方法。使用 Execa，不需要记忆任何 shell 语法，几乎所有特定于 shell 的功能都可以在 JavaScript 中表达。此外，Execa 还具有安全、跨平台和高效等优点。它没有要求任何特殊的二进制文件，也不包含任何实用程序，专注于小型和模块化。除此之外，Execa 还添加了一些额外的选项，如优雅终止、清理、交错输出等，可用于设置单个或多个命令。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反应性简史]]></title>
        <id>https://www.builder.io/blog/history-of-reactivity</id>
        <link href="https://www.builder.io/blog/history-of-reactivity"/>
        <updated>2023-03-15T15:56:57.155Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://www.builder.io/blog/history-of-reactivity">A Brief History of Reactivity</a></p><p><strong>概要：</strong></p><p>本文探讨了响应式编程在不同框架中的演变历程。作者分享了自己在使用 Macromedia Flex、AngularJS、React、Knockout、Svelte、RxJS、Vue、MobX 和 SolidJS 等框架时的经验和见解。文章指出，随着框架的发展，人们越来越注重细粒度的响应式系统，以便更好地管理状态和提高性能。作者介绍了 Qwik 框架的特点，该框架将组件序列化为 HTML，从而实现了无缝的客户端渲染和服务器端渲染的切换。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2023 年每个前端开发人员都应该知道的 6 个 CSS 片段]]></title>
        <id>https://web.dev/6-css-snippets-every-front-end-developer-should-know-in-2023/</id>
        <link href="https://web.dev/6-css-snippets-every-front-end-developer-should-know-in-2023/"/>
        <updated>2023-03-15T15:34:42.142Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://web.dev/6-css-snippets-every-front-end-developer-should-know-in-2023/">6 CSS snippets every front-end developer should know in 2023</a></p><p><strong>概要：</strong></p><p>本文介绍了六个有用的 CSS 技巧，包括使用容器查询、创建滚动吸附效果、避免使用 grid 的 position: absolute、快速制作圆形、使用层叠样式表（cascade layers）控制变体和使用逻辑属性（logical properties）来减少代码量。其中，容器查询是经过多年等待后在 2023 年终于得到了浏览器支持；滚动吸附可以帮助实现系统滚动 UX，并提供有意义的停止点；使用层叠样式表可以方便地插入新的变体，而不必担心它们会干扰原有的变体；逻辑属性可以根据书写模式和文档方向自动调整样式，从而减少代码量。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nuxt 3.3・Nuxt

努克斯特 3.3・努克斯特]]></title>
        <id>https://nuxt.com/blog/v3-3</id>
        <link href="https://nuxt.com/blog/v3-3"/>
        <updated>2023-03-15T10:13:09.696Z</updated>
        <content type="html"><![CDATA[<p><strong>原文：</strong></p><p><a href="https://nuxt.com/blog/v3-3">Nuxt 3.3 · Nuxt</a></p><p><strong>概要：</strong></p><p>Nuxt.js 发布了新版本，增加了本地模块开发、自动重启服务器和性能优化等功能。该版本还提供了一些新的组件和可组合函数，包括错误处理组件 <NuxtClientFallback> 和处理不受信任用户输入的 useHeadSafe 可组合函数。此外，该版本还改进了类型定义和 Nitro 引擎，支持自定义配置模式，并且有更好的 Chrome DevTools 支持。</p>]]></content>
    </entry>
</feed>